<file_contents>
File: C:/Users/Shad/Documents/tensigh-godot/Scripts/RelationManager.cs
```csharp
#nullable enable
using Godot;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Tensigh
{
    public class RelationManager
    {
        private readonly TextBlockManager _textBlockManager;
        private TextBlock? _relationSourceBlock;
        private Panel? _relationPanel;
        private LineEdit? _relationLabelInput;
        private OptionButton? _existingRelationsDropdown;
        private HashSet<string> _existingRelationLabels = new HashSet<string>();
        private bool _showRelations = false;

        // Constants for relation visualization
        private const float RELATION_DEPTH_OFFSET = 0.5f;
        private const float RELATION_SCALE_FACTOR = 0.7f;
        private const float RELATION_X_SKEW = 0.2f;
        private const float RELATION_Y_SKEW = 0.2f;
        private const float RELATION_BALL_SCALE = 0.3f;
        private const float RELATION_ORBIT_RADIUS = 3.0f;
        private const float RELATION_FADE_SPEED = 8.0f;
        private const float RELATION_MOVE_SPEED = 8.0f;
        private const float RELATION_ROTATION_SPEED = 0.5f;
        private const float RELATION_TEXT_SCALE = 0.6f;
        private const float RELATION_UNRELATED_FADE = 0.1f;
        private const float RELATION_RELATED_FADE = 1.0f;
        private const float RELATION_TRANSITION_TIME = 0.5f;

        // Dictionaries for relation mode transitions
        private Dictionary<string, Vector3> _targetPositions = new Dictionary<string, Vector3>();
        private Dictionary<string, float> _targetOpacities = new Dictionary<string, float>();
        private Dictionary<string, Vector3> _originalPositions = new Dictionary<string, Vector3>();
        private Dictionary<string, Vector3> _originalScales = new Dictionary<string, Vector3>();
        private Dictionary<string, float> _transitionProgress = new Dictionary<string, float>();
        private Dictionary<string, Vector3> _targetScales = new Dictionary<string, Vector3>();
        
        // Action to call SaveText on ThoughtSpace
        private Action _saveTextAction;
        private Node _parent;

        public RelationManager(Node parent, TextBlockManager textBlockManager, Action saveTextAction)
        {
            _parent = parent;
            _textBlockManager = textBlockManager;
            _saveTextAction = saveTextAction;
            CreateRelationUI();
        }

        public void CreateRelationUI()
        {
            // Create relation creation panel
            _relationPanel = new Panel
            {
                Name = "RelationPanel",
                Visible = false,
                Position = new Vector2(200, 300),
                Size = new Vector2(300, 200)
            };
            _parent.AddChild(_relationPanel);

            // Add heading label
            var headingLabel = new Label
            {
                Text = "Create Relation",
                Position = new Vector2(10, 10),
                Size = new Vector2(280, 30)
            };
            _relationPanel.AddChild(headingLabel);

            // Add dropdown for existing relation labels
            _existingRelationsDropdown = new OptionButton
            {
                Position = new Vector2(10, 50),
                Size = new Vector2(280, 30)
            };
            _relationPanel.AddChild(_existingRelationsDropdown);
            _existingRelationsDropdown.ItemSelected += (long index) => OnExistingRelationSelected(index);

            // Add text input for new relation label
            _relationLabelInput = new LineEdit
            {
                PlaceholderText = "Enter new relation label...",
                Position = new Vector2(10, 90),
                Size = new Vector2(280, 30)
            };
            _relationPanel.AddChild(_relationLabelInput);
            _relationLabelInput.TextSubmitted += (string text) => OnRelationLabelSubmitted(text);

            // Add Create and Cancel buttons
            var createButton = new Button
            {
                Text = "Create",
                Position = new Vector2(10, 130),
                Size = new Vector2(135, 30)
            };
            _relationPanel.AddChild(createButton);
            createButton.Pressed += OnCreateRelationPressed;

            var cancelButton = new Button
            {
                Text = "Cancel",
                Position = new Vector2(155, 130),
                Size = new Vector2(135, 30)
            };
            _relationPanel.AddChild(cancelButton);
            cancelButton.Pressed += OnCancelRelationPressed;
        }

        public void ShowRelationUI(TextBlock sourceBlock, TextBlock targetBlock)
        {
            _relationSourceBlock = sourceBlock;
            RefreshExistingRelationLabels();
            if (_relationPanel != null) _relationPanel.Visible = true;
            if (_relationLabelInput != null) _relationLabelInput.Text = "";
            GD.Print($"Showing relation UI for source: {sourceBlock.Id}, target: {targetBlock.Id}");
        }

        private void OnExistingRelationSelected(long index)
        {
            if (_existingRelationsDropdown == null || _relationLabelInput == null) return;
            
            if (index >= 0 && index < _existingRelationsDropdown.ItemCount)
            {
                string selectedLabel = _existingRelationsDropdown.GetItemText((int)index);
                _relationLabelInput.Text = selectedLabel;
            }
        }

        private void OnRelationLabelSubmitted(string text)
        {
            CreateRelation(text);
        }

        private void OnCreateRelationPressed()
        {
            if (_relationLabelInput == null) return;
            CreateRelation(_relationLabelInput.Text);
        }

        private void OnCancelRelationPressed()
        {
            if (_relationPanel != null) _relationPanel.Visible = false;
            _relationSourceBlock = null;
        }

        public void ShowRelationUIForAllBlocks(TextBlock sourceBlock)
        {
            // Show relation creation UI for creating relations with all blocks
            _relationSourceBlock = sourceBlock;
            
            // Check if there's only one block (no relations possible)
            if (_textBlockManager.GetAllBlocks().Count() <= 1)
            {
                GD.Print("Cannot create relations: need at least two blocks");
                return;
            }
            
            // Select a target block (any block other than source)
            var targetBlock = _textBlockManager.GetAllBlocks().FirstOrDefault(b => b != sourceBlock);
            if (targetBlock != null)
            {
                ShowRelationUI(sourceBlock, targetBlock);
            }
        }

        public void RefreshExistingRelationLabels()
        {
            if (_existingRelationsDropdown == null) return;
            
            _existingRelationsDropdown.Clear();
            
            // Add a blank option first
            _existingRelationsDropdown.AddItem("");
            
            // Add all existing labels
            foreach (var label in _existingRelationLabels)
            {
                _existingRelationsDropdown.AddItem(label);
            }
            
            GD.Print($"Refreshed relation dropdown with {_existingRelationLabels.Count} labels");
        }

        public void CreateRelation(string label)
        {
            if (_relationSourceBlock == null) return;
            
            if (string.IsNullOrWhiteSpace(label))
            {
                // If no label is provided, create relations with all blocks
                foreach (var block in _textBlockManager.GetAllBlocks())
                {
                    if (block != _relationSourceBlock)
                    {
                        var relation = new Relation(_relationSourceBlock.Id, block.Id, "");
                        _relationSourceBlock.Relations.Add(relation);
                        
                        // Add the reverse relation to the target block
                        var reverseRelation = new Relation(block.Id, _relationSourceBlock.Id, "");
                        block.Relations.Add(reverseRelation);
                    }
                }
            }
            else
            {
                // If a label is provided, create relations with all blocks that have the same relation
                var blocksWithSameRelation = _textBlockManager.GetAllBlocks().Where(b => 
                    b != _relationSourceBlock && 
                    b.Relations.Any(r => r.Label == label)).ToList();

                if (blocksWithSameRelation.Any())
                {
                    // Create relations with blocks that have the same relation
                    foreach (var block in blocksWithSameRelation)
                    {
                        var relation = new Relation(_relationSourceBlock.Id, block.Id, label);
                        _relationSourceBlock.Relations.Add(relation);
                        
                        // Add the reverse relation to the target block
                        var reverseRelation = new Relation(block.Id, _relationSourceBlock.Id, label);
                        block.Relations.Add(reverseRelation);
                    }
                }
                else
                {
                    // If no blocks have the same relation, create relations with all blocks
                    foreach (var block in _textBlockManager.GetAllBlocks())
                    {
                        if (block != _relationSourceBlock)
                        {
                            var relation = new Relation(_relationSourceBlock.Id, block.Id, label);
                            _relationSourceBlock.Relations.Add(relation);
                            
                            // Add the reverse relation to the target block
                            var reverseRelation = new Relation(block.Id, _relationSourceBlock.Id, label);
                            block.Relations.Add(reverseRelation);
                        }
                    }
                }

                // Add the label to existing labels if it's new
                if (!string.IsNullOrEmpty(label))
                {
                    _existingRelationLabels.Add(label);
                }
            }

            // Save the changes
            _saveTextAction();
            
            // Update relation visualizations for all blocks
            foreach (var block in _textBlockManager.GetAllBlocks())
            {
                UpdateRelationVisualizations(block);
            }

            if (_relationPanel != null) _relationPanel.Visible = false;
            _relationSourceBlock = null;
        }

        public void ToggleRelationVisualizations()
        {
            _showRelations = !_showRelations;
            
            GD.Print($"Toggling relations: {_showRelations}");
            
            foreach (var block in _textBlockManager.GetAllBlocks())
            {
                if (_showRelations)
                {
                    UpdateRelationVisualizations(block);
                }
                else
                {
                    // Clean up visualizations
                    foreach (var relation in block.Relations)
                    {
                        if (relation.VisualLabel != null)
                        {
                            if (relation.VisualLabel.GetParent() != null)
                            {
                                relation.VisualLabel.GetParent().RemoveChild(relation.VisualLabel);
                            }
                            relation.VisualLabel.QueueFree();
                            relation.VisualLabel = null;
                        }
                    }
                }
            }
        }

        public void PositionRelatedBlocksInOrbit(TextBlock sourceBlock)
        {
            if (sourceBlock == null) return;
            
            // Identify blocks that are related to the source block
            var relatedBlocks = new List<TextBlock>();
            foreach (var relation in sourceBlock.Relations)
            {
                var relatedBlock = _textBlockManager.GetAllBlocks().FirstOrDefault(b => b.Id == relation.TargetId);
                if (relatedBlock != null && !relatedBlocks.Contains(relatedBlock))
                {
                    relatedBlocks.Add(relatedBlock);
                }
            }
            
            // Calculate positions in an orbit around the source block
            int blockCount = relatedBlocks.Count;
            for (int i = 0; i < blockCount; i++)
            {
                float angle = (float)(2 * Math.PI * i / blockCount);
                float x = sourceBlock.Position.X + RELATION_ORBIT_RADIUS * Mathf.Cos(angle);
                float y = sourceBlock.Position.Y + RELATION_ORBIT_RADIUS * Mathf.Sin(angle);
                float z = sourceBlock.Position.Z - RELATION_DEPTH_OFFSET;
                
                var targetPosition = new Vector3(x, y, z);
                var block = relatedBlocks[i];
                
                // Store original position if not already stored
                if (!_originalPositions.ContainsKey(block.Id))
                {
                    _originalPositions[block.Id] = block.Position;
                }
                
                // Store original scale if not already stored
                if (!_originalScales.ContainsKey(block.Id))
                {
                    _originalScales[block.Id] = block.Scale;
                }
                
                // Set target position and scale
                _targetPositions[block.Id] = targetPosition;
                _targetScales[block.Id] = block.Scale * RELATION_BALL_SCALE;
                _targetOpacities[block.Id] = RELATION_RELATED_FADE;
                _transitionProgress[block.Id] = 0;
            }
            
            // For unrelated blocks, set them to fade out
            foreach (var block in _textBlockManager.GetAllBlocks())
            {
                if (block != sourceBlock && !relatedBlocks.Contains(block))
                {
                    // Store original position and scale if not already stored
                    if (!_originalPositions.ContainsKey(block.Id))
                    {
                        _originalPositions[block.Id] = block.Position;
                    }
                    
                    if (!_originalScales.ContainsKey(block.Id))
                    {
                        _originalScales[block.Id] = block.Scale;
                    }
                    
                    // Set fade target
                    _targetOpacities[block.Id] = RELATION_UNRELATED_FADE;
                    _transitionProgress[block.Id] = 0;
                }
            }
        }

        public void UpdateRelationVisualizations(TextBlock block)
        {
            if (block == null) return;
            
            // First, clean up any existing relation visualizations
            foreach (var relation in block.Relations)
            {
                if (relation.VisualLabel != null)
                {
                    if (relation.VisualLabel.GetParent() != null)
                    {
                        relation.VisualLabel.GetParent().RemoveChild(relation.VisualLabel);
                    }
                    relation.VisualLabel.QueueFree();
                    relation.VisualLabel = null;
                }
            }
            
            // If relations are not visible, just return
            if (!_showRelations) return;
            
            // Only visualize relations where this block is the source
            foreach (var relation in block.Relations)
            {
                if (relation.SourceId == block.Id)
                {
                    // Find the target block
                    var targetBlock = _textBlockManager.GetAllBlocks().FirstOrDefault(b => b.Id == relation.TargetId);
                    if (targetBlock == null) continue;
                    
                    // Create a visual representation for this relation
                    CreateRelationVisualization(block, targetBlock, relation);
                }
            }
        }

        public void CreateRelationVisualization(TextBlock sourceBlock, TextBlock targetBlock, Relation relation)
        {
            if (sourceBlock == null || targetBlock == null) return;

            // Calculate midpoint between blocks with some offset to avoid direct overlap
            var sourcePos = sourceBlock.Position;
            var targetPos = targetBlock.Position;
            var midpoint = new Vector3(
                (sourcePos.X + targetPos.X) / 2 + RELATION_X_SKEW,
                (sourcePos.Y + targetPos.Y) / 2 + RELATION_Y_SKEW,
                (sourcePos.Z + targetPos.Z) / 2 - RELATION_DEPTH_OFFSET
            );

            // Create label for the relation
            var visualLabel = new Label3D
            {
                Text = string.IsNullOrEmpty(relation.Label) ? "related" : relation.Label,
                Position = midpoint,
                Scale = new Vector3(RELATION_TEXT_SCALE, RELATION_TEXT_SCALE, RELATION_TEXT_SCALE),
                Modulate = new Color(1, 1, 0, 0.8f), // Yellow, slightly transparent
                NoDepthTest = true,
                FixedSize = true,
                Billboard = BaseMaterial3D.BillboardModeEnum.Enabled
            };

            // Store the visual label in the relation
            relation.VisualLabel = visualLabel;
            
            // Add to the scene
            _parent.AddChild(visualLabel);
            
            // Create a simple line or connection visualization if desired
            // This would require additional 3D objects (like MeshInstance3D) to create a line
            
            // Truncate long text for cleaner display
            if (relation.Label.Length > 15)
            {
                visualLabel.Text = TruncateText(relation.Label, 15);
            }
        }

        private string TruncateText(string text, int maxLength)
        {
            if (string.IsNullOrEmpty(text) || text.Length <= maxLength)
                return text;

            return text.Substring(0, maxLength - 3) + "...";
        }

        public void AddExistingRelationLabel(string label)
        {
            if (!string.IsNullOrEmpty(label))
            {
                _existingRelationLabels.Add(label);
            }
        }

        public void ClearExistingRelationLabels()
        {
            // Clean up existing visual labels first
             foreach (var block in _textBlockManager.GetAllBlocks())
             {
                 if(block.Relations != null)
                 { 
                     foreach(var relation in block.Relations)
                     {
                         relation.VisualLabel?.QueueFree(); 
                         relation.VisualLabel = null; 
                     }
                 }
             }
             // Now clear the internal set
            _existingRelationLabels.Clear();
        }

        public TextBlock? GetRelationSourceBlock()
        {
            return _relationSourceBlock;
        }

        public void SetRelationSourceBlock(TextBlock? block)
        {
            _relationSourceBlock = block;
        }

        public bool IsRelationPanelVisible()
        {
            return _relationPanel?.Visible ?? false;
        }

        public void Dispose()
        {
            // Clean up UI elements
            _relationPanel?.QueueFree();
            // Any other cleanup specific to RelationManager
        }

        // Add a method to toggle relation orbit visualization mode
        public void ToggleRelationMode(TextBlock sourceBlock)
        {
            if (sourceBlock == null) return;
            
            // Check if we're entering or exiting relation mode
            bool isEntering = !_targetPositions.ContainsKey(sourceBlock.Id);
            
            if (isEntering)
            {
                // Entering relation mode - position blocks in orbit
                PositionRelatedBlocksInOrbit(sourceBlock);
                
                // Update visualization
                GD.Print($"Entering relation orbit mode for block: {sourceBlock.Id}");
            }
            else
            {
                // Exiting relation mode - restore original positions
                foreach (var block in _textBlockManager.GetAllBlocks())
                {
                    if (_originalPositions.ContainsKey(block.Id))
                    {
                        // Set target to original position and scale
                        _targetPositions[block.Id] = _originalPositions[block.Id];
                        _targetScales[block.Id] = _originalScales[block.Id];
                        _targetOpacities[block.Id] = 1.0f;
                    }
                }
                
                GD.Print("Exiting relation orbit mode");
            }
            
            // In a real implementation, you would need to add code to
            // update positions over time in the _Process method
        }

        // Add a process method to handle position transitions
        public void Process(double delta)
        {
            // Only process if we have transitions in progress
            if (_transitionProgress.Count == 0) return;
            
            bool stillTransitioning = false;
            
            // Update positions and scales based on transition progress
            foreach (var block in _textBlockManager.GetAllBlocks())
            {
                if (!_targetPositions.ContainsKey(block.Id)) continue;
                
                if (_transitionProgress[block.Id] < 1.0f)
                {
                    // Update transition progress
                    _transitionProgress[block.Id] += (float)(delta * RELATION_MOVE_SPEED);
                    _transitionProgress[block.Id] = Mathf.Min(_transitionProgress[block.Id], 1.0f);
                    
                    // Calculate interpolated position
                    float t = _transitionProgress[block.Id];
                    block.Position = _originalPositions[block.Id].Lerp(_targetPositions[block.Id], t);
                    
                    // Calculate interpolated scale
                    block.Scale = _originalScales[block.Id].Lerp(_targetScales[block.Id], t);
                    block.Label.Scale = block.Scale;
                    
                    // Calculate interpolated opacity
                    float opacity = Mathf.Lerp(1.0f, _targetOpacities[block.Id], t);
                    block.Label.Modulate = new Color(
                        block.Label.Modulate.R,
                        block.Label.Modulate.G, 
                        block.Label.Modulate.B, 
                        opacity
                    );
                    
                    stillTransitioning = true;
                }
            }
            
            // If all transitions are complete, clear the lists
            if (!stillTransitioning)
            {
                _transitionProgress.Clear();
            }
        }

        // --- Save/Load Related Methods ---

        /// <summary>
        /// Updates the provided PageData object with the current state of the Relations.
        /// </summary>
        public void UpdatePageData(TextBlockCollection pageData)
        {
            if (pageData == null) return;

            var allRelationsOnPage = new HashSet<Relation>(new RelationComparer());
            // Use the blocks provided by TextBlockManager as the source of truth for relations
            foreach (var block in _textBlockManager.GetAllBlocks())
            {
                 if (block.Relations != null)
                 {
                     foreach (var relation in block.Relations)
                     {
                         // Only save relations where this block is the source to avoid duplicates
                         if (relation.SourceId == block.Id)
                         {
                             // Clean up visual label before saving data
                             relation.VisualLabel?.QueueFree(); 
                             relation.VisualLabel = null; 
                             allRelationsOnPage.Add(relation);
                         }
                     }
                 }
            }
            pageData.Relations = allRelationsOnPage.ToList();
            GD.Print($"RelationManager updated PageData with {pageData.Relations.Count} relations.");
        }

        /// <summary>
        /// Clears existing relation visuals and loads relations based on provided data.
        /// </summary>
        public void LoadRelationsForPage(IEnumerable<Relation> relationData)
        {
            ClearExistingRelationLabels(); // Also cleans up visuals
            _existingRelationLabels.Clear(); // Clear the known labels

            var currentBlocks = _textBlockManager.GetAllBlocks().ToList(); // Get current blocks
            var blockLookup = currentBlocks.ToDictionary(b => b.Id);

            if (relationData == null || !currentBlocks.Any()) 
            {
                GD.Print("RelationManager: No relations to load or no blocks available.");
                return;
            }

            GD.Print($"RelationManager: Loading {relationData.Count()} relations from saved data");
            
            foreach (var relation in relationData)
            {
                if (blockLookup.TryGetValue(relation.SourceId, out var sourceBlock) && 
                    blockLookup.TryGetValue(relation.TargetId, out var targetBlock))
                {
                    // Ensure relations list is initialized
                    sourceBlock.Relations ??= new List<Relation>();
                    targetBlock.Relations ??= new List<Relation>();

                    // Add relation if not already present (prevent duplicates from save format)
                    // Note: We add both forward and reverse relations here based on the saved list
                    // which should only contain the forward ones (source->target)
                    if (!sourceBlock.Relations.Any(r => r.TargetId == relation.TargetId && r.Label == relation.Label))
                    {
                        sourceBlock.Relations.Add(relation); 
                    }

                    var reverseRelation = new Relation(relation.TargetId, relation.SourceId, relation.Label);
                    if (!targetBlock.Relations.Any(r => r.TargetId == reverseRelation.TargetId && r.Label == reverseRelation.Label))
                    {
                        targetBlock.Relations.Add(reverseRelation);
                    }
                    
                    // Add label to the known set and update dropdown if UI exists
                    if (!string.IsNullOrEmpty(relation.Label))
                    {
                        AddExistingRelationLabel(relation.Label);
                    }
                }
                else
                {
                    GD.PushWarning($"RelationManager: Could not find source ({relation.SourceId}) or target ({relation.TargetId}) block for relation.");
                }
            }
            
            RefreshExistingRelationLabels(); // Update dropdown UI

            // Update visualizations if they are enabled
            if (_showRelations)
            {
                 foreach (var block in currentBlocks) 
                 { 
                     UpdateRelationVisualizations(block); 
                 }
            }
            GD.Print($"RelationManager: Finished loading relations.");
        }

        // Moved from ThoughtSpace.cs
        private class RelationComparer : IEqualityComparer<Relation>
        {
            public bool Equals(Relation? x, Relation? y) 
            { 
                if (x == null && y == null) return true; 
                if (x == null || y == null) return false; 
                // Consider relations equal if source/target are swapped
                return (x.SourceId == y.SourceId && x.TargetId == y.TargetId && x.Label == y.Label) || 
                       (x.SourceId == y.TargetId && x.TargetId == y.SourceId && x.Label == y.Label); 
            }
            public int GetHashCode(Relation obj) 
            { 
                if (obj == null) return 0; 
                // Use XOR for symmetrical hash code regardless of source/target order
                return (obj.SourceId.GetHashCode() ^ obj.TargetId.GetHashCode()) + (obj.Label?.GetHashCode() ?? 0); 
            }
        }
    }
} 
```

File: C:/Users/Shad/Documents/tensigh-godot/Scripts/TextBlockManager.cs
```csharp
#nullable enable
using Godot;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Tensigh
{
    /// <summary>
    /// Manages the lifecycle, state, and visualization of TextBlock nodes.
    /// </summary>
    public class TextBlockManager : IDisposable
    {
        private List<TextBlock> _textBlocks = new List<TextBlock>();
        private TextBlock? _currentBlock = null;
        private Node3D? _textContainer = null; // Parent node for block visuals
        private bool _showBoundingBoxes = true;

        // Shared resources for bounding boxes
        private static BoxMesh? _sharedBoxMesh = null;
        private static StandardMaterial3D? _sharedBoxMaterial = null;

        private bool _disposed = false;

        public TextBlockManager()
        {
            // Initialization logic moved to Initialize method
        }

        /// <summary>
        /// Initializes the manager with essential references.
        /// Should be called once after instantiation.
        /// </summary>
        /// <param name="textContainer">The Node3D that will parent the TextBlock visuals.</param>
        public void Initialize(Node3D textContainer)
        {
            _textContainer = textContainer ?? throw new ArgumentNullException(nameof(textContainer));
            InitializeSharedResources();
        }

        // --------------------------------------------------
        // Public API Methods (Implementation Moved)
        // --------------------------------------------------

        /// <summary>
        /// Updates the provided PageData object with the current state of the TextBlocks.
        /// </summary>
        public void UpdatePageData(TextBlockCollection pageData)
        {
            if (pageData == null) return;

            var currentBlockData = new List<TextBlock>();
            foreach (var blockNode in _textBlocks)
            {
                // Update the data stored in the TextBlock object itself 
                // (which will be serialized)
                if (blockNode.Label != null && GodotObject.IsInstanceValid(blockNode.Label))
                {
                    blockNode.Position = blockNode.Label.Position;
                    blockNode.Scale = blockNode.Label.Scale;
                    // Text is assumed to be up-to-date via editing
                }
                // Note: Relations are updated by RelationManager
                currentBlockData.Add(blockNode); 
            }
            pageData.Blocks = currentBlockData;
            GD.Print($"TextBlockManager updated PageData with {_textBlocks.Count} blocks.");
        }

        /// <summary>
        /// Clears existing blocks and loads new ones based on provided data.
        /// Accepts IEnumerable<TextBlock> as TextBlock is already prepared for serialization.
        /// </summary>
        public void LoadBlocksFromPage(IEnumerable<TextBlock> blockData)
        {
            ClearAllBlocks(); // Clear existing first
            if (_textContainer == null)
            {
                GD.PrintErr("TextBlockManager not initialized with a TextContainer.");
                return;
            }

            float currentY = 0; // Initial Y position for the first block
            float padding = 0.05f; // Padding between blocks

            foreach (var loadedBlockData in blockData)
            {
                // Create a new TextBlock instance using data from the loaded block.
                // We use the loaded text and ID, but calculate position based on vertical layout.
                var newBlock = new TextBlock(loadedBlockData.Text, Vector3.Zero) // Initial position is temporary
                {
                    Scale = loadedBlockData.Scale, // Copy scale
                    Id = loadedBlockData.Id,       // Copy ID
                    Relations = new List<Relation>() // Initialize empty relations (handled by RelationManager)
                };
                newBlock.Label.Scale = loadedBlockData.Scale; // Ensure label scale matches
                // Don't copy position from loadedBlockData, recalculate based on layout

                _textBlocks.Add(newBlock);
                _textContainer.AddChild(newBlock.Label); // Add label to scene first

                // Create bounding box - this will calculate and store BoxHeight/Width/Depth
                CreateBoundingBoxWithSharedResources(newBlock);

                // NOW set the final position based on currentY
                newBlock.Position = new Vector3(0, currentY, 0);
                newBlock.Label.Position = newBlock.Position;
                if (newBlock.BoundingBox != null) 
                { 
                    // Ensure bounding box position matches, adjusting for depth centering
                    newBlock.BoundingBox.Position = new Vector3(newBlock.Position.X, newBlock.Position.Y, newBlock.Position.Z - newBlock.BoxDepth / 2f);
                }

                // Calculate Y position for the NEXT block using the calculated height of the CURRENT block
                // Ensure BoxHeight was correctly calculated and stored by CreateBoundingBox/UpdateBoundingBoxSize
                currentY -= (newBlock.BoxHeight + padding); 

                // Note: Visibility of bounding box is handled within CreateBoundingBox
            }
            
            SetCurrentBlock(_textBlocks.FirstOrDefault()); // Set first block as current

            GD.Print($"TextBlockManager loaded {_textBlocks.Count} blocks.");
        }

        /// <summary>
        /// Removes all TextBlocks from the list and frees their associated nodes.
        /// </summary>
        public void ClearAllBlocks()
        {
            if (_textContainer == null) {
                 GD.PrintErr("TextBlockManager cannot clear blocks without a TextContainer.");
                 return;
            }

            // Use IsInstanceValid for safety before accessing nodes
            foreach (var block in _textBlocks)
            {
                if (block.Label != null && GodotObject.IsInstanceValid(block.Label))
                {
                    if (block.Label.GetParent() == _textContainer) // Ensure it's our child
                    {
                        _textContainer.RemoveChild(block.Label);
                    }
                    block.Label.QueueFree();
                }
                if (block.BoundingBox != null && GodotObject.IsInstanceValid(block.BoundingBox))
                {
                    if (block.BoundingBox.GetParent() == _textContainer) // Ensure it's our child
                    {
                         _textContainer.RemoveChild(block.BoundingBox);
                    }
                    block.BoundingBox.QueueFree();
                }
            }
            _textBlocks.Clear();
            SetCurrentBlock(null);
            GD.Print("TextBlockManager cleared all blocks.");
        }

        /// <summary>
        /// Creates a new TextBlock, adds it to the scene and internal list.
        /// </summary>
        /// <returns>The newly created TextBlock.</returns>
        public TextBlock? CreateNewBlock(string initialText, Vector3 position)
        {
            if (_textContainer == null)
            {
                GD.PrintErr("TextBlockManager not initialized with a TextContainer.");
                return null;
            }

            // Logic moved from ThoughtSpace.CreateNewTextBlock to calculate position if needed
            if (position == Vector3.Zero && _textBlocks.Any())
            {
                TextBlock? lowestBlock = null;
                float lowestY = float.MaxValue;
                
                foreach (var existingBlock in _textBlocks)
                {
                    if (lowestBlock == null || existingBlock.Position.Y < lowestY)
                    {
                        lowestBlock = existingBlock;
                        lowestY = existingBlock.Position.Y;
                    }
                }
                
                if (lowestBlock != null)
                { 
                    float boxHeight = CalculateBlockHeight(lowestBlock); // Use helper
                    float padding = 0.05f; // Consider making this a constant
                    position = new Vector3(0, lowestY - (boxHeight + padding), 0);
                }
                else
                { 
                    position = new Vector3(0, -0.5f, 0); // Fallback position
                }
            }
            
            // Logic moved from ThoughtSpace.CreateTextBlockWithSharedResources
            var block = new TextBlock(initialText, position);
            // block.IsEditing = true; // Should editing state be managed here or outside?
            _textBlocks.Add(block);
            _textContainer.AddChild(block.Label);
            CreateBoundingBoxWithSharedResources(block); // Create and add the bounding box
            SetCurrentBlock(block); // Set as current
            
            // Note: Adding to the specific PageManager's currentPage.Blocks 
            // is now the responsibility of the caller (ThoughtSpace)
            
            return block;
        }

        /// <summary>
        /// Deletes a specific TextBlock from the list and scene.
        /// </summary>
        public void DeleteBlock(TextBlock blockToDelete)
        {
            if (blockToDelete == null) return;

            // Logic moved from ThoughtSpace.DeleteCurrentBlock
            int currentIndex = _textBlocks.IndexOf(blockToDelete);
            if (currentIndex == -1) 
            { 
                GD.Print($"WARN: TextBlockManager: Block {blockToDelete.Id} not found for deletion.");
                return; // Not in our list
            }
            
            _textBlocks.RemoveAt(currentIndex);
            
            // Free nodes safely
            if (blockToDelete.Label != null && GodotObject.IsInstanceValid(blockToDelete.Label))
            {
                blockToDelete.Label.QueueFree();
            }
            if (blockToDelete.BoundingBox != null && GodotObject.IsInstanceValid(blockToDelete.BoundingBox))
            {
                blockToDelete.BoundingBox.QueueFree();
            }
            
            // Update current block if the deleted one was current
            if (_currentBlock == blockToDelete)
            {
                if (currentIndex > 0 && currentIndex <= _textBlocks.Count) // Check index valid after removal
                {
                    SetCurrentBlock(_textBlocks[currentIndex - 1]); // Select previous
                }
                else
                {
                    SetCurrentBlock(_textBlocks.FirstOrDefault()); // Select first or null
                }
            }
            GD.Print($"TextBlockManager deleted block {blockToDelete.Id}.");
            // Note: Saving state (SaveText()) is responsibility of caller (ThoughtSpace)
        }

        /// <summary>
        /// Arranges the TextBlocks vertically in the scene.
        /// </summary>
        public void ArrangeBlocksVertically()
        {
            if (!_textBlocks.Any()) return;

            // Logic moved from ThoughtSpace.ArrangeBlocksVertically
            _textBlocks.Sort((a, b) => a.Position.Y.CompareTo(b.Position.Y)); // Sort by current Y pos

            float currentY = 0; 
            float padding = 0.05f; 
            
            foreach (var block in _textBlocks) 
            { 
                float boxHeight = CalculateBlockHeight(block); // Use helper
                
                // Set new position based on arrangement
                block.Position = new Vector3(0, currentY, 0); 
                if (block.Label != null && GodotObject.IsInstanceValid(block.Label)){
                     block.Label.Position = block.Position;
                }
                
                // Update bounding box visuals to match new position
                UpdateBoundingBoxVisuals(block);
                 
                currentY -= (boxHeight + padding); // Move down for the next block
            }
            GD.Print($"TextBlockManager arranged {_textBlocks.Count} blocks vertically.");
        }

        /// <summary>
        /// Sets the visibility of all bounding boxes.
        /// </summary>
        public void SetBoundingBoxesVisibility(bool isVisible)
        {
            _showBoundingBoxes = isVisible;
            // TODO: Move logic from ThoughtSpace.HandleToggleBoundingBoxesRequested
            foreach (var block in _textBlocks)
            {
                if (block.BoundingBox != null) block.BoundingBox.Visible = _showBoundingBoxes;
            }
        }

        /// <summary>
        /// Updates the position and scale of a block's bounding box (e.g., during drag).
        /// </summary>
        public void UpdateBoundingBoxVisuals(TextBlock block)
        {
            if (block == null) return;
            // TODO: Consolidate/Move logic from ThoughtSpace.UpdateBoundingBoxForTextBlock
             GD.PrintErr($"Placeholder: Updating bbox visuals for {block.Id}. Logic needs implementation.");
            if (block.BoundingBox != null) {
                block.BoundingBox.Position = block.Position; 
                // Potentially recalculate scale based on text here too?
            }
        }

        // --------------------------------------------------
        // Accessors
        // --------------------------------------------------

        public IEnumerable<TextBlock> GetAllBlocks() => _textBlocks;
        public TextBlock? GetCurrentBlock() => _currentBlock;
        public void SetCurrentBlock(TextBlock? block)
        {
             // Optional: Add logic here if changing current block requires actions
             _currentBlock = block;
        }

        // --------------------------------------------------
        // Shared Resource Management (Logic to be moved)
        // --------------------------------------------------

        private void InitializeSharedResources()
        {
            // TODO: Move logic from ThoughtSpace.InitializeSharedResources
            try
            {
                if (_sharedBoxMesh == null || !GodotObject.IsInstanceValid(_sharedBoxMesh)) 
                { 
                    _sharedBoxMesh = new BoxMesh { Size = new Vector3(1.0f, 1.0f, 0.01f) }; 
                    GD.Print("TextBlockManager initialized shared box mesh"); 
                }
                if (_sharedBoxMaterial == null || !GodotObject.IsInstanceValid(_sharedBoxMaterial)) 
                { 
                    _sharedBoxMaterial = new StandardMaterial3D
                    { 
                        AlbedoColor = new Color(0.2f, 0.5f, 0.8f, 0.15f),
                        Transparency = BaseMaterial3D.TransparencyEnum.Alpha,
                        CullMode = BaseMaterial3D.CullModeEnum.Disabled,
                        ShadingMode = BaseMaterial3D.ShadingModeEnum.Unshaded,
                        EmissionEnabled = true,
                        Emission = new Color(0.2f, 0.5f, 0.8f, 0.15f)
                    };
                    GD.Print("TextBlockManager initialized shared box material");
                }
            }
            catch (Exception ex) { GD.PrintErr($"TextBlockManager error initializing shared resources: {ex.Message}"); }
        }

        private void CleanupSharedResources()
        {
             // TODO: Move logic from ThoughtSpace.CleanupResources (shared mesh/material part)
            try 
            {
                GD.Print("TextBlockManager cleaning up shared resources...");
                if (_sharedBoxMesh != null && GodotObject.IsInstanceValid(_sharedBoxMesh)) 
                { 
                    _sharedBoxMesh.Dispose(); 
                    _sharedBoxMesh = null; 
                    GD.Print("Disposed shared box mesh.");
                }
                if (_sharedBoxMaterial != null && GodotObject.IsInstanceValid(_sharedBoxMaterial)) 
                { 
                    _sharedBoxMaterial.Dispose(); 
                    _sharedBoxMaterial = null; 
                    GD.Print("Disposed shared box material.");
                }
            }
            catch (Exception ex) { GD.PrintErr($"TextBlockManager error cleaning up shared resources: {ex.Message}"); }
        }

        // --------------------------------------------------
        // Private Helpers (Implementation Moved)
        // --------------------------------------------------

        private void CreateBoundingBoxWithSharedResources(TextBlock block)
        {
             if (block == null || _textContainer == null) return;
             // Logic moved from ThoughtSpace.CreateBoundingBoxWithSharedResources
             try 
             { 
                 InitializeSharedResources(); // Ensure shared mesh/material exist
                 var boundingBox = new MeshInstance3D 
                 { 
                     Name = $"BoundingBox_{block.Id}", 
                     Mesh = _sharedBoxMesh, 
                     MaterialOverride = _sharedBoxMaterial 
                 }; 
                 block.BoundingBox = boundingBox; 
                 
                 if (block.BoxWidth > 0 && block.BoxHeight > 0) 
                 { 
                     // Use pre-calculated size if available (e.g., from loaded data)
                     boundingBox.Scale = new Vector3(block.BoxWidth, block.BoxHeight, block.BoxDepth); 
                     boundingBox.Position = new Vector3(block.Position.X, block.Position.Y, block.Position.Z - block.BoxDepth / 2.0f); // Adjust Z 
                 } 
                 else 
                 { 
                     UpdateBoundingBoxSize(block); // Calculate size based on text content if needed
                 } 
                 
                 boundingBox.Visible = _showBoundingBoxes; 
                 _textContainer.AddChild(boundingBox); 
             } 
             catch (Exception ex) 
             { 
                 GD.PrintErr($"TextBlockManager error creating bounding box for block {block.Id}: {ex.Message}"); 
             }
        }

        private void UpdateBoundingBoxSize(TextBlock block)
        { 
            // Logic moved from ThoughtSpace.UpdateBoundingBoxSize
            if (block == null || block.BoundingBox == null || block.Label == null) return; 
            try 
            { 
                var lines = block.Text?.Split('\n') ?? Array.Empty<string>();
                int maxLineLength = lines.Any() ? lines.Max(line => line.Length) : 0;
                int lineCount = Math.Max(lines.Length, 1); // Ensure at least 1 line height
                
                Vector3 labelScale = block.Label.Scale;
                
                // --- Text Size Estimation --- 
                float characterWidth = 0.06f; // These values might need adjustment
                float lineHeight = 0.1f;
                float textWidth = maxLineLength * characterWidth * labelScale.X;
                float textHeight = lineCount * lineHeight * labelScale.Y;
                // --- End Estimation --- 
                
                float widthPadding = textWidth * 0.2f;
                float heightPadding = textHeight * 0.2f;
                
                textWidth = Mathf.Max(textWidth, 0.1f); // Min width
                textHeight = Mathf.Max(textHeight, 0.1f); // Min height
                
                textHeight = textHeight * 2.0f; // Extra height factor
                
                float boxWidth = textWidth + widthPadding;
                float boxHeight = textHeight + heightPadding;
                float boxDepth = 0.01f;
                
                // Update block's stored dimensions
                block.BoxWidth = boxWidth;
                block.BoxHeight = boxHeight;
                block.BoxDepth = boxDepth;
                
                // Apply scale and position to the MeshInstance
                block.BoundingBox.Scale = new Vector3(boxWidth, boxHeight, boxDepth);
                block.BoundingBox.Position = new Vector3(block.Position.X, block.Position.Y, block.Position.Z - boxDepth / 2f); // Center depth
                block.BoundingBox.Visible = _showBoundingBoxes;
            } 
            catch (Exception ex) 
            { 
                GD.PrintErr($"TextBlockManager error updating bounding box size for block {block.Id}: {ex.Message}"); 
            }
        }

        // Helper moved from ThoughtSpace.UpdateBoundingBoxForTextBlock
        // Used by ArrangeBlocksVertically and potentially dragging (UpdateBoundingBoxVisuals)
        private void UpdateBoundingBoxForTextBlock(TextBlock block)
        {
            if (block == null || block.BoundingBox == null) 
                return;
                
            block.BoundingBox.Position = block.Position + new Vector3(0,0, -block.BoxDepth / 2f); // Adjust Z

            // Option 1: Recalculate size (like UpdateBoundingBoxSize) - more accurate but potentially slower
            // UpdateBoundingBoxSize(block);

            // Option 2: Use simplified calculation (as was in ThoughtSpace) - faster but less accurate
             var lines = block.Text?.Split('\n') ?? Array.Empty<string>();
             int maxLineLength = lines.Any() ? lines.Max(line => line.Length) : 0;
             float width = maxLineLength * 0.1f; // Simplified width calc
             float height = lines.Length * 0.15f; // Simplified height calc
             block.BoundingBox.Scale = new Vector3(Mathf.Max(width, 0.1f), Mathf.Max(height, 0.1f), block.BoxDepth); // Use existing depth, ensure min size
        }

        // Helper to estimate/calculate block height, used in CreateNewBlock and ArrangeBlocksVertically
        private float CalculateBlockHeight(TextBlock block)
        {
             if (block.BoundingBox != null && block.BoundingBox.Mesh is BoxMesh boxMesh && GodotObject.IsInstanceValid(boxMesh))
             {
                 // Use actual bounding box size if available and valid
                 return boxMesh.Size.Y * block.BoundingBox.Scale.Y;
             }
             else
             { 
                 // Estimate height based on text lines if bounding box isn't ready/valid
                 var lines = block.Text?.Split('\n') ?? Array.Empty<string>();
                 var worldCharHeight = 0.08f; // Consider making this a constant
                 return Math.Max(lines.Length, 1) * worldCharHeight * 2.0f * block.Scale.Y;
             }
        }

        // --------------------------------------------------
        // IDisposable Implementation
        // --------------------------------------------------

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (_disposed) return;

            if (disposing)
            {
                // Dispose managed state (managed objects).
                GD.Print("Disposing TextBlockManager...");
                // Note: Clearing blocks might be better done explicitly via ClearAllBlocks 
                // depending on whether the manager or ThoughtSpace owns the nodes ultimately.
                // Let's assume ClearAllBlocks is called before Dispose for node cleanup.
                _textBlocks.Clear(); 
                CleanupSharedResources(); // Dispose shared mesh/material
            }

            // Free unmanaged resources (unmanaged objects) and override finalizer
            // Set large fields to null
            _textContainer = null;
            _currentBlock = null;
            _textBlocks = null!; // Suppress warning, list is cleared/nulled

            _disposed = true;
        }
    }
} 
```

File: C:/Users/Shad/Documents/tensigh-godot/Scripts/ThoughtSpace.cs
```csharp
using Godot;
using System;
using System.Collections.Generic;
using System.IO;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Linq;
using System.Threading.Tasks; // Added for async/await in DeferredChangeScene usage if needed

namespace Tensigh
{
    public partial class ThoughtSpace : Node3D, IDisposable
    {
        // REMOVED UI Button Fields
        // private Button _returnButton;
        // private Button _loadDocumentButton;
        // private Button _toggleWebViewerButton;
        // private Button _prevPageButton;
        // private Button _nextPageButton;
        // private Button _newPageButton;
        // private Label _pageLabel; // Handled by UIManager
        // private Label _coordinateLabel; // Handled by UIManager

        // Services and Managers
        internal WebViewerManager _webViewerManager;
        internal PageManager _pageManager;
        internal RelationManager _relationManager;
    
        internal ThoughtSpaceUIManager _uiManager;
        internal ThoughtSpaceInputHandler _inputHandler;
        private SceneManager _sceneManager; // Changed from SceneManager?
        
        private CameraController _cameraController;
        
        private TextBlockManager _textBlockManager;
        private const float TEXT_SCALE = 0.5f;
        private const float MAX_TEXT_WIDTH = 400.0f;
        private const float MAX_TEXT_HEIGHT = 300.0f;
        private const float LINE_HEIGHT = 0.15f;
        private Node3D _textContainer;
        internal TextBlock _draggedBlock;
        private PersistenceManager _persistenceManager;
        private bool _disposed = false;

        // Constants for Camera Initialization
        private static readonly Vector3 INITIAL_CAMERA_OFFSET = new Vector3(0, 0, 4);
        private const float INITIAL_CAMERA_ZOOM_SPEED = 0.5f;
        private const float INITIAL_CAMERA_PAN_SPEED = 0.01f;

        public ThoughtSpace()
        {
           // Explicitly initialize other nullable fields
            _webViewerManager = null;
            _pageManager = null;
            _relationManager = null;
            _inputHandler = null;
            _cameraController = null;
            _textBlockManager = null;
            _textContainer = null;
            _draggedBlock = null;
            _persistenceManager = null;
            _uiManager = null;
        }

        public override void _Ready()
        {
            try
            {
                // Initialize SceneManager (it's an autoload)
                _sceneManager = GetNodeOrNull<SceneManager>("/root/SceneManager");
                if (_sceneManager == null)
                {
                    GD.PrintErr("SceneManager autoload node not found!");
                    // Handle the error appropriately, maybe disable scene changing functionality
                }
                else
                {
                     // Pass the SaveText method to the SceneManager
                    _sceneManager.Initialize(SaveText);
                    GD.Print("SceneManager autoload found and initialized in ThoughtSpace.");
                }

                _pageManager = new PageManager();
                _pageManager.CurrentPageChanged += LoadPageFromManager; // Subscribe to page change

            _textContainer = GetNode<Node3D>("TextContainer");
                if (_textContainer == null) { GD.PrintErr("TextContainer not found"); return; }

                // --- Text Block Manager Setup ---
                _textBlockManager = new TextBlockManager();
                _textBlockManager.Initialize(_textContainer);
                // --- End Text Block Manager Setup ---

                // --- Camera Setup --- 
                var cameraNode = GetNode<Camera3D>("Camera3D");
                if (cameraNode == null) { GD.PrintErr("Camera3D node not found"); return; }
                _cameraController = new CameraController();
                _cameraController.Initialize(cameraNode, INITIAL_CAMERA_OFFSET, INITIAL_CAMERA_ZOOM_SPEED, INITIAL_CAMERA_PAN_SPEED);
                _cameraController.CameraTransformChanged += HandleCameraTransformChanged;
                AddChild(_cameraController); 
                // --- End Camera Setup ---

                _webViewerManager = GetNode<WebViewerManager>("/root/WebViewerManager");
                if (_webViewerManager == null) { GD.PrintErr("WebViewerManager singleton not found"); }

                _uiManager = new ThoughtSpaceUIManager();
                _uiManager.Initialize(this, _pageManager);

                // Subscribe to UI Manager Events
                _uiManager.ReturnRequested += HandleReturnRequested;
                _uiManager.NewPageRequested += HandleNewPageRequested;
                _uiManager.PrevPageRequested += HandlePrevPageRequested;
                _uiManager.NextPageRequested += HandleNextPageRequested;
                _uiManager.ToggleWebViewerRequested += HandleToggleWebViewerRequested;
                _uiManager.ToggleBoundingBoxesRequested += HandleToggleBoundingBoxesRequested;
                _uiManager.ToggleRelationsRequested += HandleToggleRelationsRequested;

                // Pass managers to Input Handler
                _inputHandler = new ThoughtSpaceInputHandler(this, _cameraController, _textBlockManager);

                // Update RelationManager constructor call
                _relationManager = new RelationManager(this, _textBlockManager, () => SaveText());

                // Instantiate Persistence Manager
                _persistenceManager = new PersistenceManager(_pageManager, _textBlockManager, _relationManager);

            LoadText();
                
                if (_pageManager.Pages.Count == 0)
                {
                    _pageManager.AddPage("Page 1");
                    var defaultPage = _pageManager.GetCurrentPage();
                    if (defaultPage != null) {
                       var newBlock = _textBlockManager.CreateNewBlock("Start typing here...", Vector3.Zero);
                       if (newBlock != null) {
                           defaultPage.Blocks.Add(newBlock);
                           _textBlockManager.SetCurrentBlock(newBlock);
                       }
                    }
                }
                
                _uiManager.UpdatePageUI();
            }
            catch (Exception ex)
            { GD.PrintErr($"Error in _Ready: {ex.Message}"); }
        }

        public override void _Process(double delta)
        {
            _inputHandler?.Process(delta);
            _relationManager?.Process(delta);
        }

        public override void _Input(InputEvent @event)
        {
            _inputHandler?.ProcessInput(@event);
        }

        /// <summary>
        /// Saves the current state via the PersistenceManager.
        /// </summary>
        internal void SaveText()
        {
            _persistenceManager?.Save("user://thoughts.json");
        }

        /// <summary>
        /// Loads the state via the PersistenceManager and updates the scene.
        /// </summary>
        internal void LoadText()
        { 
            if (_persistenceManager == null) 
            {
                GD.PrintErr("LoadText: PersistenceManager is null!");
                if (_pageManager != null && !_pageManager.Pages.Any())
                {
                    _pageManager.AddPage("Page 1");
                    LoadPageFromManager();
                }
                _uiManager?.UpdatePageUI();
                        return;
                    }
                    
            bool loadSuccess = _persistenceManager.Load("user://thoughts.json");

            if (_pageManager == null)
            {
                GD.PrintErr("LoadText: PageManager is null after load attempt!");
                _uiManager?.UpdatePageUI();
                            return;
                        }
                        
            if (!loadSuccess)
            { 
                GD.Print("ThoughtSpace: PersistenceManager failed to load. Ensuring default page exists.");
                 if (!_pageManager.Pages.Any()) { _pageManager.AddPage("Page 1"); }
                 if (_pageManager.GetCurrentPage() == null && _pageManager.Pages.Any()) { _pageManager.SwitchToPage(0); }
                                }
                                else
                                {
                GD.Print("ThoughtSpace: PersistenceManager loaded successfully.");
                 if (_pageManager.GetCurrentPage() == null && _pageManager.Pages.Any()) 
                 { 
                     GD.Print("ThoughtSpace: Load successful, but no current page set. Switching to page 0.");
                     _pageManager.SwitchToPage(0);
                 }
            }

                                LoadPageFromManager();
            
            _uiManager?.UpdatePageUI();
        }

        private void HandleCameraTransformChanged(Vector3 position, Vector3 rotation)
        {
            _uiManager?.SetCoordinateLabelText($"Camera: {position:F2}, {rotation:F2}");
        }

        private void HandleReturnRequested()
        {
            GD.Print("Return to Desk requested.");
            // Use SceneManager to change scene, checking for null
            if (_sceneManager != null)
            {
                _sceneManager.ChangeScene("res://Scenes/DeskRoom.tscn");
            }
            else
            {
                GD.PrintErr("HandleReturnRequested: SceneManager is null, cannot change scene.");
            }
        }

        private void HandleNewPageRequested()
        {
            if (_pageManager == null) { GD.PrintErr("HandleNewPageRequested: PageManager is null!"); return; }

            _pageManager.AddPage($"Page {_pageManager.Pages.Count + 1}");
            
            var newBlock = _textBlockManager?.CreateNewBlock("Start typing here...", Vector3.Zero);
            
            var currentPage = _pageManager?.GetCurrentPage(); 
            if (currentPage != null && newBlock != null) 
            { 
                 currentPage.Blocks.Add(newBlock); 
            }
            else
            {
                 GD.PrintErr("HandleNewPageRequested: Failed to get current page data or create new block after adding page.");
            }

            _uiManager?.UpdatePageUI(); 
        }

        private void HandlePrevPageRequested()
        {
            if (_pageManager != null && _pageManager.CurrentPageIndex > 0)
            {
                _pageManager.SwitchToPage(_pageManager.CurrentPageIndex - 1);
                _uiManager?.UpdatePageUI();
            }
        }

        private void HandleNextPageRequested()
        { 
            if (_pageManager != null && _pageManager.CurrentPageIndex < _pageManager.Pages.Count - 1)
            {
                _pageManager.SwitchToPage(_pageManager.CurrentPageIndex + 1);
                _uiManager?.UpdatePageUI();
            }
        }
        
        private void HandleToggleWebViewerRequested()
        {
            try
            {
                if (_webViewerManager == null) { _webViewerManager = GetNode<WebViewerManager>("/root/WebViewerManager"); if (_webViewerManager == null) { GD.PrintErr("WebViewerManager singleton not found"); return; } }
                _webViewerManager.ToggleVisibility();
                _uiManager?.UpdateWebViewerToggleText(_webViewerManager.IsVisible()); 
                var currentBlock = _textBlockManager?.GetCurrentBlock();
                if (_webViewerManager.IsVisible() && currentBlock != null && !string.IsNullOrEmpty(currentBlock.Text)) { string text = currentBlock.Text.Trim(); if (text.StartsWith("http://") || text.StartsWith("https://")) { OpenWebPage(text); } }
            }
            catch (Exception ex) { GD.PrintErr($"Error toggling WebViewer: {ex.Message}"); }
        }

        internal void HandleToggleBoundingBoxesRequested()
        {
            bool currentVisibility = _textBlockManager?.GetAllBlocks().FirstOrDefault()?.BoundingBox?.Visible ?? false;
            bool newVisibility = !currentVisibility;
            _textBlockManager?.SetBoundingBoxesVisibility(newVisibility);
        }
        
        internal void HandleToggleRelationsRequested()
        {
            _relationManager?.ToggleRelationVisualizations();
        }
        
        internal void DisconnectAllSignals()
        {
            GD.Print("Disconnecting non-UI signals (if any)..."); 
        }

        internal void UpdateTextDisplay()
        {
            var currentBlock = _textBlockManager?.GetCurrentBlock();
            if (currentBlock == null) 
                return;
            
            currentBlock.UpdateTextDisplay();
            
            if (currentBlock.TextColor != Colors.White)
            {
                currentBlock.Label.Modulate = currentBlock.TextColor;
            }
            
            if (currentBlock.IsEditing)
            {
                if (currentBlock.ShowCursor)
                {
                    currentBlock.Label.OutlineSize = 1;
                    currentBlock.Label.OutlineModulate = new Color(1, 1, 1, 0.8f);
                }
                else
                {
                    currentBlock.Label.OutlineSize = 0;
                    currentBlock.Label.OutlineModulate = new Color(0, 0, 0, 0);
                }
            }
            else
            {
                currentBlock.Label.OutlineSize = 0;
                currentBlock.Label.OutlineModulate = new Color(0, 0, 0, 0);
            }
        }

        internal void LoadPageFromManager(TextBlockCollection pageDataFromEvent = null)
        {
            var page = _pageManager?.GetCurrentPage();
            if (page != null)
            {
                GD.Print($"LoadPageFromManager: Loading page '{page.Name}'");
                _textBlockManager?.LoadBlocksFromPage(page.Blocks ?? Enumerable.Empty<TextBlock>());
                _relationManager?.LoadRelationsForPage(page.Relations ?? Enumerable.Empty<Relation>());

                var blockPositions = _textBlockManager?.GetAllBlocks().Select(b => b.Position);
                if (blockPositions != null) 
                { 
                    _cameraController?.Reset(blockPositions); 
                }
                else
                {
                     _cameraController?.Reset();
                }
                GD.Print($"LoadPageFromManager: Completed loading page '{page.Name}'");
                }
                else
                {
                GD.Print("LoadPageFromManager: No current page to load. Clearing blocks.");
                 _textBlockManager?.ClearAllBlocks();
                 _relationManager?.ClearExistingRelationLabels(); 
                 _cameraController?.Reset(); 
            } 
        }
        
        internal void OpenWebPage(string url)
        {
            try
            {
                if (_webViewerManager == null)
                {
                    _webViewerManager = GetNode<WebViewerManager>("/root/WebViewerManager");
                }
                    
                    if (_webViewerManager == null)
                    {
                        GD.PrintErr("WebViewerManager singleton not found");
                        return;
                    }
                _webViewerManager.NavigateToUrl(url);
                _uiManager?.UpdateWebViewerToggleText(true);
            }
            catch (Exception ex)
            {
                GD.PrintErr($"Error opening web page: {ex.Message}");
            }
        }

        /// <summary>
        /// Performs the actual loading of a document from a given path.
        /// Called by the UIManager after a file is selected.
        /// </summary>
        internal void PerformLoadDocument(string path)
        {
            try
            {
                if (_pageManager != null)
                {
                    _pageManager.LastOpenedPath = Path.GetDirectoryName(path);
                    GD.Print($"ThoughtSpace: Saved last opened path: {_pageManager.LastOpenedPath}");
                }

                var documentLoader = new DocumentLoader();
                var loadedPageData = documentLoader.LoadDocumentAsPage(path);

                if (loadedPageData == null)
                {
                    GD.PrintErr($"ThoughtSpace: Failed to load document data from {path}.");
                    // Optionally show an error to the user via UIManager
                    return;
                }

                if (_pageManager != null)
                {
                    _pageManager.AddExistingPage(loadedPageData);
                }
                else
                {
                     GD.PrintErr("ThoughtSpace: PageManager is null, cannot add loaded page.");
                     return;
                }

                // LoadPageFromManager will trigger UI update via its call chain
                LoadPageFromManager();

                SaveText(); // Save the newly added page state
            }
            catch (Exception e)
            {
                GD.PrintErr($"Error in PerformLoadDocument: {e.Message}\n{e.StackTrace}");
                // Optionally show an error to the user via UIManager
            }
        }

        public new void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }
        
        protected virtual new void Dispose(bool disposing)
        {
             if (_disposed) return;
            if (disposing)
            {
                  if (_pageManager != null)
                  {
                      _pageManager.CurrentPageChanged -= LoadPageFromManager;
                  }
                  if (_uiManager != null)
                  {
                      _uiManager.ReturnRequested -= HandleReturnRequested;
                      _uiManager.NewPageRequested -= HandleNewPageRequested;
                      _uiManager.PrevPageRequested -= HandlePrevPageRequested;
                      _uiManager.NextPageRequested -= HandleNextPageRequested;
                      _uiManager.ToggleWebViewerRequested -= HandleToggleWebViewerRequested;
                      _uiManager.ToggleBoundingBoxesRequested -= HandleToggleBoundingBoxesRequested;
                      _uiManager.ToggleRelationsRequested -= HandleToggleRelationsRequested;
                  }

                  if (_cameraController != null)
                  {
                      _cameraController.CameraTransformChanged -= HandleCameraTransformChanged;
                  }

                  _uiManager?.Cleanup(); 
                  _relationManager?.Dispose(); 
                  CleanupResources(); 
             }
             _disposed = true;
        }
        
        private void CleanupResources()
        {
            try 
            {
                GD.Print("Cleaning up ThoughtSpace base resources...");
                GD.Print("ThoughtSpace base resources cleanup completed.");
                }
                catch (Exception ex)
                {
                GD.PrintErr($"Error during ThoughtSpace base resources cleanup: {ex.Message}"); 
            }
        }

        public override void _ExitTree()
        {
             Dispose(); base._ExitTree();
        }
    }
} 
```

File: C:/Users/Shad/Documents/tensigh-godot/Scripts/ThoughtSpaceInputHandler.cs
```csharp
#nullable enable
using Godot;
using System;
using System.Linq;

namespace Tensigh
{
    public class ThoughtSpaceInputHandler
    {
        private readonly ThoughtSpace _thoughtSpace; // Reference to main class
        private readonly CameraController _cameraController; // Reference to camera controller
        private readonly TextBlockManager _textBlockManager; // NEW Reference
        private const double CURSOR_BLINK_RATE = 0.5; // Moved from ThoughtSpace

        // Input State Fields (Moved from ThoughtSpace)
        private Vector2 _lastMousePosition;
        private bool _isDraggingCamera = false; // Renamed for clarity
        private bool _isDraggingText = false;
        private TextBlock? _draggedBlock = null; // Local drag state
        private Vector3 _dragPlaneNormal;
        private Vector3 _dragStartPosition;
        private Key _lastKeyPressed;
        private double _cursorBlinkTime = 0; // Now used in Process method

        public ThoughtSpaceInputHandler(ThoughtSpace thoughtSpace, CameraController cameraController, TextBlockManager textBlockManager)
        {
            _thoughtSpace = thoughtSpace ?? throw new ArgumentNullException(nameof(thoughtSpace));
            _cameraController = cameraController ?? throw new ArgumentNullException(nameof(cameraController));
            _textBlockManager = textBlockManager ?? throw new ArgumentNullException(nameof(textBlockManager));
        }

        // Method called from ThoughtSpace._Process
        public void Process(double delta)
        {
            _cursorBlinkTime += delta;
            if (_cursorBlinkTime >= CURSOR_BLINK_RATE)
            {
                _cursorBlinkTime = 0;
                var currentBlock = _textBlockManager.GetCurrentBlock();
                if (currentBlock != null && currentBlock.IsEditing)
                {
                    currentBlock.ShowCursor = !currentBlock.ShowCursor;
                    _thoughtSpace.UpdateTextDisplay(); // Call the method on the main class
                }
            }
        }

        public void ProcessInput(InputEvent @event)
        {
            // Get current block from manager at the start of input processing
            var currentBlock = _textBlockManager.GetCurrentBlock();

            // --- Logic copied and adapted from ThoughtSpace._Input ---
            if (@event is InputEventKey keyEvent && keyEvent.Pressed)
            {
                GD.Print($"Key pressed: {keyEvent.Keycode}, Unicode: {keyEvent.Unicode}, Last Key Pressed: {_lastKeyPressed}");
                
                // First, handle Enter key explicitly to prevent UI navigation
                if (keyEvent.Keycode == Key.Enter)
                {
                    _thoughtSpace.GetViewport().SetInputAsHandled();
                    if (_lastKeyPressed == Key.Enter) // Double-Enter
                    {
                        var currentPage = _thoughtSpace._pageManager?.GetCurrentPage();
                        if (currentBlock != null && currentBlock.IsEditing)
                        {
                            currentBlock.IsEditing = false;
                            currentBlock.ShowCursor = false; 
                            _thoughtSpace.UpdateTextDisplay();
                        }
                        Vector3 newPosition = currentBlock != null ? currentBlock.Position + new Vector3(0, -1, 0) : Vector3.Zero;
                        var newBlock = _textBlockManager.CreateNewBlock("New block...", newPosition);
                        if (currentPage != null && newBlock != null) currentPage.Blocks.Add(newBlock);
                        _thoughtSpace.UpdateTextDisplay();
                        _lastKeyPressed = Key.Unknown; 
                        return;
                    }
                    
                    // Single Enter press
                    if (currentBlock != null && currentBlock.IsEditing)
                    {
                        currentBlock.Text = currentBlock.Text.Insert(currentBlock.CursorPosition, "\n");
                        currentBlock.CursorPosition++;
                        _thoughtSpace.UpdateTextDisplay();
                        if (currentBlock.BoundingBox != null)
                        {
                            _textBlockManager.UpdateBoundingBoxVisuals(currentBlock);
                        }
                    }
                    _lastKeyPressed = Key.Enter;
                    return;
                }
                
                // --- Other Key Handling ---
                if (keyEvent.Keycode == Key.Escape)
                {
                     if (currentBlock != null)
                     {
                         currentBlock.IsEditing = !currentBlock.IsEditing;
                         if (!currentBlock.IsEditing) { _thoughtSpace.SaveText(); } // Assuming SaveText is accessible
                         else 
                         {
                             _cursorBlinkTime = 0; // Reset blink time when starting edit
                             currentBlock.ShowCursor = true; 
                             currentBlock.CursorPosition = currentBlock.Text?.Length ?? 0; 
                         }
                         _thoughtSpace.UpdateTextDisplay();
                     }
                     _lastKeyPressed = keyEvent.Keycode;
                }
                else if (keyEvent.Keycode == Key.B && keyEvent.CtrlPressed)
                {
                    _thoughtSpace.HandleToggleBoundingBoxesRequested(); // Assuming handler is accessible
                    _lastKeyPressed = keyEvent.Keycode;
                }
                else if (currentBlock != null && currentBlock.IsEditing)
                {
                     _cursorBlinkTime = 0; // Reset cursor blink timer when typing
                     currentBlock.ShowCursor = true; // Ensure cursor is visible when typing starts
                     currentBlock.CursorPosition = Mathf.Clamp(currentBlock.CursorPosition, 0, currentBlock.Text?.Length ?? 0);
                    
                     // Arrow keys, Home, End
                     if (keyEvent.Keycode == Key.Left) { currentBlock.CursorPosition = Math.Max(0, currentBlock.CursorPosition - 1); _thoughtSpace.UpdateTextDisplay(); _thoughtSpace.GetViewport().SetInputAsHandled(); return; }
                     else if (keyEvent.Keycode == Key.Right) { currentBlock.CursorPosition = Math.Min(currentBlock.Text?.Length ?? 0, currentBlock.CursorPosition + 1); _thoughtSpace.UpdateTextDisplay(); _thoughtSpace.GetViewport().SetInputAsHandled(); return; }
                     else if (keyEvent.Keycode == Key.Home)
                     {
                         if (currentBlock.CursorPosition > 0)
                         {
                             string? text = currentBlock.Text;
                             if (text != null)
                             {
                                 int nl = text.LastIndexOf('\n', currentBlock.CursorPosition - 1);
                                 currentBlock.CursorPosition = (nl == -1) ? 0 : nl + 1;
                             }
                             else
                             {
                                 currentBlock.CursorPosition = 0;
                             }
                             _thoughtSpace.UpdateTextDisplay();
                             _thoughtSpace.GetViewport().SetInputAsHandled();
                             return;
                         }
                     }
                     else if (keyEvent.Keycode == Key.End)
                     {
                         string? text = currentBlock.Text;
                         if (text != null)
                         {
                             int nl = text.IndexOf('\n', currentBlock.CursorPosition);
                             currentBlock.CursorPosition = (nl == -1) ? text.Length : nl;
                         }
                         else
                         {
                             currentBlock.CursorPosition = 0;
                         }
                         _thoughtSpace.UpdateTextDisplay();
                         _thoughtSpace.GetViewport().SetInputAsHandled();
                         return;
                     }

                     // Backspace & Character Input
                     if (keyEvent.Unicode != 0 || keyEvent.Keycode == Key.Backspace)
                     {
                         string? text = currentBlock.Text;
                         if (keyEvent.Keycode == Key.Backspace)
                         {
                             if (text != null && text.Length > 0 && currentBlock.CursorPosition > 0)
                             {
                                 currentBlock.Text = text.Remove(currentBlock.CursorPosition - 1, 1);
                                 currentBlock.CursorPosition--;
                             }
                         }
                         else if (!char.IsControl((char)keyEvent.Unicode))
                         {
                             currentBlock.Text = (text ?? "").Insert(currentBlock.CursorPosition, ((char)keyEvent.Unicode).ToString());
                             currentBlock.CursorPosition++;
                         }
                         
                         _thoughtSpace.UpdateTextDisplay();
                         if (currentBlock.BoundingBox != null) { _textBlockManager.UpdateBoundingBoxVisuals(currentBlock); }
                         GD.Print($"Text updated to: {currentBlock.Text}");
                         _thoughtSpace.GetViewport().SetInputAsHandled();
                     }
                    
                     HandleTextInput(currentBlock, currentBlock.Text); // Call local helper (Text can be null here, handled in method)
                     _lastKeyPressed = keyEvent.Keycode;
                }
                else if (keyEvent.Keycode == Key.Tab && keyEvent.ShiftPressed)
                {
                     GD.Print("Shift+Tab pressed, creating new text block");
                     Vector3 newPosition = currentBlock != null ? currentBlock.Position + new Vector3(0, -2, 0) : Vector3.Zero;
                     var currentPage = _thoughtSpace._pageManager?.GetCurrentPage();
                     var newBlock = _textBlockManager.CreateNewBlock("New block...", newPosition);
                     if (currentPage != null && newBlock != null) currentPage.Blocks.Add(newBlock);
                     _thoughtSpace.UpdateTextDisplay();
                     _lastKeyPressed = keyEvent.Keycode;
                     _thoughtSpace.GetViewport().SetInputAsHandled();
                }
                 else if (currentBlock != null && !currentBlock.IsEditing)
                 {
                     _lastKeyPressed = keyEvent.Keycode;
                 }
                
                 // Ctrl for relation creation
                 if (keyEvent.Keycode == Key.Ctrl && currentBlock != null && !currentBlock.IsEditing)
                 {
                     _thoughtSpace._relationManager?.ShowRelationUIForAllBlocks(currentBlock);
                 }
            }
            else if (@event is InputEventMouseButton mouseButton)
            {
                HandleMouseInput(mouseButton); // Call local helper
            }
            else if (@event is InputEventMouseMotion mouseMotion)
            {
                HandleMouseMotion(mouseMotion); // Call local helper
            }
        }

        // --- Helper methods moved and adapted ---

        private void HandleTextInput(TextBlock block, string? text)
        {
            // Logic copied from ThoughtSpace.HandleTextInput
            if (block == null) return; 
            GD.Print($"Handling text input: {text ?? "<null>"}");
            if (!string.IsNullOrEmpty(text)) 
            {
                block.Text = text;
                _thoughtSpace.UpdateTextDisplay(); // Assuming UpdateTextDisplay is accessible
            }
            else
            {
                block.Text = string.Empty; // Set to empty instead of deleting immediately? Or handle deletion?
                _thoughtSpace.UpdateTextDisplay();
                // Consider if deleting the block here is the right behavior when text becomes null/empty
                // _textBlockManager.DeleteBlock(block); // Use manager to delete - Maybe not here?
            }
            
            // Check for URL should happen only if text is not null/empty
            if (!string.IsNullOrEmpty(text) && (text.StartsWith("http://") || text.StartsWith("https://")))
            {
                _thoughtSpace.OpenWebPage(text); // Assuming OpenWebPage is accessible
            }
        }

        private void HandleMouseInput(InputEventMouseButton mouseButton)
        {
             // Logic copied from ThoughtSpace.HandleMouseInput
            if (mouseButton.ButtonIndex == MouseButton.Left)
            {
                if (mouseButton.Pressed)
                {
                    var cameraNode = _cameraController?.GetCameraNode();
                    if (cameraNode == null) return; // Need camera for drag plane

                    var hoveredBlock = _textBlockManager.GetAllBlocks().FirstOrDefault(b => b.IsHovered); // Access via _textBlockManager
                    if (hoveredBlock != null)
                    {
                        if (Input.IsKeyPressed(Key.Ctrl)) // Input is a singleton, accessible anywhere
                        {
                            var sourceBlock = _thoughtSpace._relationManager?.GetRelationSourceBlock();
                            if (sourceBlock == null) { _thoughtSpace._relationManager?.SetRelationSourceBlock(hoveredBlock); GD.Print($"Selected source block for relation: {hoveredBlock.Id}"); }
                            else if (sourceBlock != hoveredBlock) { _thoughtSpace._relationManager?.ShowRelationUI(sourceBlock, hoveredBlock); }
                        }
                        else
                        {
                            _isDraggingText = true;
                            _draggedBlock = hoveredBlock; // Access via _textBlockManager
                            _dragPlaneNormal = -cameraNode.Transform.Basis.Z; // Use CameraController node
                            _dragStartPosition = _draggedBlock.Position;
                            _textBlockManager.SetCurrentBlock(_draggedBlock); // Set current block via manager
                            
                            if (mouseButton.DoubleClick) 
                            { 
                                if(_draggedBlock != null) 
                                {
                                    _draggedBlock.IsEditing = true; 
                                     _cursorBlinkTime = 0; // Reset blink time when starting edit via double-click
                                    _draggedBlock.ShowCursor = true;
                                }
                                _thoughtSpace.UpdateTextDisplay(); 
                                GD.Print("Double-click detected, editing mode enabled");
                            }
                        }
                    }
                    else 
                    {
                         _isDraggingCamera = true; // Start dragging camera
                         _lastMousePosition = mouseButton.Position;
                    }
                }
                else // Mouse Button Released
                {
                    if (_isDraggingText && _draggedBlock != null) { GD.Print($"Finished dragging block at position: {_draggedBlock.Position}"); }
                    _isDraggingCamera = false;
                    _isDraggingText = false;
                    _draggedBlock = null;
                }
            }
            else if (mouseButton.ButtonIndex == MouseButton.Right && mouseButton.Pressed) 
            {
                 _cameraController?.Reset(); // Use CameraController method
            }
            else if (mouseButton.ButtonIndex == MouseButton.WheelUp) 
            {
                 _cameraController?.Zoom(-1); // Zoom In 
            }
            else if (mouseButton.ButtonIndex == MouseButton.WheelDown) 
            {
                 _cameraController?.Zoom(1); // Zoom Out
            }
        }

        private void HandleMouseMotion(InputEventMouseMotion mouseMotion)
        {
            var cameraNode = _cameraController?.GetCameraNode();
            if (cameraNode == null) return;

            // Logic copied from ThoughtSpace.HandleMouseMotion
            if (_isDraggingText && _draggedBlock != null)
            {
                var mouseRay = cameraNode.ProjectRayNormal(mouseMotion.Position);
                var mouseRayOrigin = cameraNode.ProjectRayOrigin(mouseMotion.Position);
                var intersection = GeometryUtils.CalculateRayPlaneIntersection(mouseRayOrigin, mouseRay, _dragStartPosition, _dragPlaneNormal); // Use ThoughtSpace helper
                
                if (intersection.HasValue)
                {
                    _draggedBlock.Position = intersection.Value;
                    _draggedBlock.Label.Position = intersection.Value;
                    if (_draggedBlock.BoundingBox != null) { _textBlockManager.UpdateBoundingBoxVisuals(_draggedBlock); } // Use ThoughtSpace helper
                    _thoughtSpace._relationManager?.UpdateRelationVisualizations(_draggedBlock);
                    foreach (var block in _textBlockManager.GetAllBlocks())
                    {
                        if (block != _draggedBlock && block.Relations != null && block.Relations.Any(r => r.TargetId == _draggedBlock.Id))
                        {
                            _thoughtSpace._relationManager?.UpdateRelationVisualizations(block);
                        }
                    }
                    _textBlockManager.SetCurrentBlock(_draggedBlock);
                }
            }
            else if (!_isDraggingCamera && !_isDraggingText) // Hover Check (only if not dragging anything)
            {
                var mousePos = _thoughtSpace.GetViewport().GetMousePosition();
                var rayOrigin = cameraNode.ProjectRayOrigin(mousePos);
                var rayDirection = cameraNode.ProjectRayNormal(mousePos);
                foreach (var block in _textBlockManager.GetAllBlocks()) 
                { 
                     block.IsHovered = GeometryUtils.IsRayIntersectingBox(rayOrigin, rayDirection, block); // Use ThoughtSpace helper
                }
            }
            else if (_isDraggingCamera) // Camera Drag
            {
                Vector2 delta = mouseMotion.Position - _lastMousePosition;
                _lastMousePosition = mouseMotion.Position;
                if (delta.LengthSquared() > 0) // Only pan if mouse actually moved
                {
                     _cameraController?.Pan(delta); // Use CameraController method
                }
            }
        }
    }
} 
```

File: C:/Users/Shad/Documents/tensigh-godot/Scripts/GDCefWrapper.gd
```gdscript
extends Node

# The GDCef class should be registered by the extension system
const CEF_ARTIFACTS_PATH = "res://cef_artifacts"

# Since we're using C# instead of the GDCef extension directly
const HOME_URL = "https://www.google.com"
const RADIO_URL = "http://streaming.radio.co/s9378c22ee/listen"

# For demo/placeholder functionality
var viewport_texture: ViewportTexture
var is_initialized = false
var viewport: SubViewport
var timer: Timer
var tree_connected = false

# CEF-related variables
var _cef = null  # Reference to the GDCef instance
var browser = null  # Reference to the browser instance

signal browser_paint(texture)
signal page_loaded(url)
signal page_failed_loading(err_code, err_msg)
signal download_updated(file, percentage, browser)
# Memorize if the mouse was pressed
@onready var mouse_pressed : bool = false


func _ready():
	print("GDCefWrapper: initialized")
	# See API.md for more details. CEF Configuration is:
	#   resource_path := {"artifacts", CEF_ARTIFACTS_FOLDER}
	#   resource_path := {"exported_artifacts", application_real_path()}
	#   {"incognito":false}
	#   {"cache_path", resource_path / "cache"}
	#   {"root_cache_path", resource_path / "cache"}
	#   {"browser_subprocess_path", resource_path / SUBPROCESS_NAME }
	#   {"log_file", resource_path / "debug.log"}
	#   {log_severity", "warning"}
	#   {"remote_debugging_port", 7777}
	#   {"exception_stack_size", 5}
	#   {"enable_media_stream", false}
	#
	# Configurate CEF. In incognito mode cache directories not used and in-memory
	# caches are used instead and no data is persisted to disk.
	#
	# artifacts: allows path such as "build" or "res://cef_artifacts/". Note that "res://"
	# will use ProjectSettings.globalize_path but exported projects don't support globalize_path:
	# https://docs.godotengine.org/en/3.5/classes/class_projectsettings.html#class-projectsettings-method-globalize-path
	print("Creating GDCef instance...")
	_cef = GDCef.new()
	print("GDCef instance created successfully")
	add_child(_cef)
	
	# Initialize with the correct parameters
	if not _cef.initialize({
		"incognito": true, 
		"locale": "en-US", 
		"artifacts_path": CEF_ARTIFACTS_PATH
	}):
		push_error("Failed to initialize GDCef")
		get_tree().quit()
		return
		
	print("CEF initialized successfully!")
	print("CEF version: " + _cef.get_full_version())

	# Wait one frame for the texture rect to get its size
	await get_tree().process_frame
	
	# Find the TextureRect node
	# First check if it exists in the expected path
	var texture_rect = get_node_or_null("Panel/TextureRect")
	
	# If not found in direct path, try finding it in the parent
	if texture_rect == null:
		print("TextureRect not found at Panel/TextureRect, checking in parent...")
		if get_parent() != null:
			texture_rect = get_parent().get_node_or_null("TextureRect")
	
	# If still not found, check for the first TextureRect in the scene
	if texture_rect == null:
		print("TextureRect not found in parent, looking for any TextureRect...")
		# Try the WebViewer.cs script's TextureRect
		var parent = get_parent()
		if parent != null:
			for child in parent.get_children():
				if child is TextureRect:
					texture_rect = child
					print("Found TextureRect in parent's children: ", child.name)
					break
	
	# If we still don't have a TextureRect, log an error and exit
	if texture_rect == null:
		push_error("No TextureRect found in the scene! Unable to create browser.")
		get_tree().quit()
		return
	
	print("Using TextureRect: ", texture_rect)
	
	# See API.md for more details. Browser configuration is:
	#   {"frame_rate", 30}
	#   {"javascript", true}
	#   {"javascript_close_windows", false}
	#   {"javascript_access_clipboard", false}
	#   {"javascript_dom_paste", false}
	#   {"image_loading", true}
	#   {"databases", true}
	#   {"webgl", true}
	browser = _cef.create_browser(HOME_URL, texture_rect, {"javascript":true})
	
	# Make sure the browser was created before trying to use it
	if browser != null:
		browser.set_zoom_level(0.05)
		print("Browser created successfully")
	else:
		push_error("Failed to create browser")
		get_tree().quit()
		return
	
	is_initialized = true

func _check_for_leaks():
	# Periodically check if any of our resources might be leaking
	if not is_instance_valid(viewport) and viewport != null:
		print("WARNING: Viewport reference exists but instance is invalid")
	if not is_instance_valid(timer) and timer != null:
		print("WARNING: Timer reference exists but instance is invalid")

func _on_node_removed(node):
	# If a parent node is being removed, make sure we clean up
	if node == self || (node != null && get_parent() != null && node == get_parent()) || (get_tree() != null && node == get_tree().get_root()):
		_cleanup_resources()

func _cleanup_resources():
	print("GDCefWrapper: Cleaning up resources")
	
	# First disconnect our own signals to prevent callbacks
	if tree_connected && get_tree() != null:
		if get_tree().has_signal("node_removed") && get_tree().is_connected("node_removed", _on_node_removed):
			get_tree().node_removed.disconnect(_on_node_removed)
		if get_tree().has_signal("process_frame") && get_tree().is_connected("process_frame", _check_for_leaks):
			get_tree().process_frame.disconnect(_check_for_leaks)
		tree_connected = false
	
	# Call shutdown explicitly on browser instance if it exists
	if browser != null && is_instance_valid(browser):
		print("GDCefWrapper: Shutting down browser")
		# First close the browser page
		browser.close()
		# Then free the node
		browser.queue_free()
		browser = null
	
	# Shut down the CEF instance if it exists
	if _cef != null && is_instance_valid(_cef):
		print("GDCefWrapper: Shutting down CEF instance")
		# Call explicit shutdown
		if is_initialized:
			_cef.shutdown()
		# Then free the node
		_cef.queue_free()
		_cef = null
	
	# Clean up timer
	if timer != null:
		if timer.is_connected("timeout", _on_timer_timeout):
			timer.timeout.disconnect(_on_timer_timeout)
		if is_instance_valid(timer) && timer.get_parent() == self:
			timer.queue_free()
		timer = null
	
	# Clean up viewport and its children
	if viewport != null:
		# Explicitly free all viewport children
		if is_instance_valid(viewport):
			for child in viewport.get_children():
				if is_instance_valid(child):
					child.queue_free()
			if viewport.get_parent() == self:
				viewport.queue_free()
		viewport = null
	
	# Clear texture reference
	viewport_texture = null
	is_initialized = false
	
	print("GDCefWrapper: Resources cleaned up")

func _on_timer_timeout():
	# Change background color periodically to show it's working
	if viewport != null && is_instance_valid(viewport):
		var panel = viewport.get_node_or_null("ViewportControl/ViewportPanel")
		if panel != null && is_instance_valid(panel):
			var style = panel.get_theme_stylebox("panel", "Panel") as StyleBoxFlat
			if style != null:
				var h = randf_range(0, 1.0)
				style.bg_color = Color.from_hsv(h, 0.7, 0.8, 1.0)
				panel.add_theme_stylebox_override("panel", style)

func _exit_tree():
	print("GDCefWrapper: _exit_tree called")
	_cleanup_resources()

func _notification(what):
	if what == NOTIFICATION_PREDELETE:
		print("GDCefWrapper: NOTIFICATION_PREDELETE received")
		_cleanup_resources()
	elif what == NOTIFICATION_WM_CLOSE_REQUEST:
		print("GDCefWrapper: NOTIFICATION_WM_CLOSE_REQUEST received")
		_cleanup_resources()

# Stub methods to replace the original functionality
func create_browser(url, texture_rect, settings = {}):
	print("GDCefWrapper: create_browser called with URL: ", url)
	
	# If we have a texture_rect, set the texture
	if texture_rect != null && is_instance_valid(texture_rect):
		texture_rect.texture = viewport_texture
		print("GDCefWrapper: Set texture to texture_rect: ", texture_rect)
	
	# Direct texture application to quad mesh in parent scene (if exists)
	var parent_scene = get_parent()
	if parent_scene != null && is_instance_valid(parent_scene) && parent_scene.get_parent() != null && is_instance_valid(parent_scene.get_parent()) && parent_scene.get_parent().has_node("Quad"):
		var quad = parent_scene.get_parent().get_node("Quad")
		if quad != null && is_instance_valid(quad):
			var material = quad.get_surface_override_material(0)
			if material != null:
				material.albedo_texture = viewport_texture
				print("GDCefWrapper: Applied texture directly to quad mesh")
	
	return self

func load_url(url):
	print("GDCefWrapper: load_url called with URL: ", url)
	
	# Update the label in our placeholder with the URL
	if viewport != null && is_instance_valid(viewport):
		var label = viewport.get_node_or_null("ViewportControl/ViewportLabel") 
		if label != null && is_instance_valid(label):
			label.text = "Loading: " + url
	
	emit_signal("page_loaded", url)
	return true

func set_zoom_level(delta):
	print("GDCefWrapper: set_zoom_level called with delta: ", delta)
	return true

func get_url():
	return HOME_URL

func enable_ad_block(enable):
	print("GDCefWrapper: enable_ad_block called with value: ", enable)
	return true

func add_ad_block_pattern(pattern):
	print("GDCefWrapper: add_ad_block_pattern called with pattern: ", pattern)
	return true

func set_audio_muted(mute):
	print("GDCefWrapper: set_audio_muted called with value: ", mute)
	return true

func get_error():
	return "No errors in C# compatible wrapper"

func get_full_version():
	return "C# Compatibility Version 1.0"

func shutdown():
	print("GDCefWrapper: shutdown called")
	_cleanup_resources()
	is_initialized = false 




# ==============================================================================
# Home button pressed: get the browser node and load a new page.
# ==============================================================================
func _on_Home_pressed():
	browser.load_url(HOME_URL)
	pass

# ==============================================================================
# Go to previously visited page
# ==============================================================================
func _on_Prev_pressed():
	browser.previous_page()
	pass

# ==============================================================================
# Go to next page
# ==============================================================================
func _on_Next_pressed():
	browser.next_page()
	pass

# ==============================================================================
# Callback when a page has ended to load: we print a message
# ==============================================================================
func _on_page_loaded(node):
	$Panel/Label.set_text(node.name + ": page " + node.get_url() + " loaded")

# ==============================================================================
# Callback when a page has ended to load with failure.
# Display a load error message using a data: URI.
# ==============================================================================
func _on_page_failed_loading(err_code, err_msg, node):
	if err_code == -3:
		return
	push_error("The browser " + node.name + " failed loading " + \
		node.get_url() + ": " + err_msg)
	pass

# ==============================================================================
# On new URL entered
# ==============================================================================
func _on_TextEdit_text_changed(new_text):
	browser.load_url(new_text)

# ==============================================================================
# Get mouse events and broadcast them to CEF
# ==============================================================================
func _on_TextureRect_gui_input(event):
	if event is InputEventMouseButton:
		if event.button_index == MOUSE_BUTTON_WHEEL_UP:
			browser.set_mouse_wheel_vertical(2)
		elif event.button_index == MOUSE_BUTTON_WHEEL_DOWN:
			browser.set_mouse_wheel_vertical(-2)
		elif event.button_index == MOUSE_BUTTON_LEFT:
			mouse_pressed = event.pressed
			if mouse_pressed:
				browser.set_mouse_left_down()
			else:
				browser.set_mouse_left_up()
		elif event.button_index == MOUSE_BUTTON_RIGHT:
			mouse_pressed = event.pressed
			if mouse_pressed:
				browser.set_mouse_right_down()
			else:
				browser.set_mouse_right_up()
		else:
			mouse_pressed = event.pressed
			if mouse_pressed:
				browser.set_mouse_middle_down()
			else:
				browser.set_mouse_middle_up()
	elif event is InputEventMouseMotion:
		if mouse_pressed == true :
			browser.set_mouse_left_down()
		browser.set_mouse_moved(event.position.x, event.position.y)
	pass

# ==============================================================================
# Make the CEF browser reacts from keyboard events.
# ==============================================================================
func _input(event):
	if event is InputEventKey:
		browser.set_key_pressed(
			event.unicode if event.unicode != 0 else event.keycode, # Godot3: event.scancode,
			event.pressed, event.shift_pressed, event.alt_pressed, event.is_command_or_control_pressed())
	pass

```

File: C:/Users/Shad/Documents/tensigh-godot/Scenes/DeskRoom.tscn
```tscn
[gd_scene load_steps=13 format=3 uid="uid://b6x8v0j6y5n3q"]

[ext_resource type="Script" uid="uid://cns34nv14v816" path="res://Scripts/DeskRoom.cs" id="1_2k4m3"]

[sub_resource type="Environment" id="Environment_1"]
background_mode = 1
background_color = Color(0.2, 0.2, 0.2, 1)
ambient_light_source = 2
ambient_light_color = Color(0.5, 0.5, 0.5, 1)
tonemap_mode = 2
glow_enabled = true

[sub_resource type="BoxMesh" id="BoxMesh_4"]
size = Vector3(20, 0.1, 20)

[sub_resource type="StandardMaterial3D" id="StandardMaterial3D_4"]
albedo_color = Color(0.8, 0.8, 0.8, 1)

[sub_resource type="BoxMesh" id="BoxMesh_1"]
size = Vector3(4, 0.1, 3)

[sub_resource type="StandardMaterial3D" id="StandardMaterial3D_1"]
albedo_color = Color(0.6, 0.4, 0.2, 1)

[sub_resource type="BoxMesh" id="BoxMesh_2"]
size = Vector3(0.1, 1.2, 0.1)

[sub_resource type="StandardMaterial3D" id="StandardMaterial3D_2"]
albedo_color = Color(0.4, 0.3, 0.2, 1)

[sub_resource type="SphereMesh" id="SphereMesh_1"]
radius = 1.2
height = 2.0
is_hemisphere = true

[sub_resource type="StandardMaterial3D" id="StandardMaterial3D_5"]
transparency = 1
albedo_color = Color(0.8, 0.9, 1, 0.6)
rim_enabled = true
rim = 0.2
backlight = Color(0.8, 0.9, 1, 1)

[sub_resource type="SphereShape3D" id="SphereShape3D_1"]
radius = 1.2

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_1"]
bg_color = Color(0, 0.2, 0.4, 0.8)
border_width_left = 2
border_width_top = 2
border_width_right = 2
border_width_bottom = 2
border_color = Color(0.4, 0.6, 0.8, 1)
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8
shadow_size = 2
shadow_offset = Vector2(2, 2)

[node name="DeskRoom" type="Node3D"]
script = ExtResource("1_2k4m3")

[node name="WorldEnvironment" type="WorldEnvironment" parent="."]
environment = SubResource("Environment_1")

[node name="Floor" type="MeshInstance3D" parent="."]
mesh = SubResource("BoxMesh_4")
surface_material_override/0 = SubResource("StandardMaterial3D_4")

[node name="Desk" type="Node3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0.6, 0)

[node name="TableTop" type="MeshInstance3D" parent="Desk"]
mesh = SubResource("BoxMesh_1")
surface_material_override/0 = SubResource("StandardMaterial3D_1")

[node name="Leg1" type="MeshInstance3D" parent="Desk"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -1.95, -0.6, -1.45)
mesh = SubResource("BoxMesh_2")
surface_material_override/0 = SubResource("StandardMaterial3D_2")

[node name="Leg2" type="MeshInstance3D" parent="Desk"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 1.95, -0.6, -1.45)
mesh = SubResource("BoxMesh_2")
surface_material_override/0 = SubResource("StandardMaterial3D_2")

[node name="Leg3" type="MeshInstance3D" parent="Desk"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -1.95, -0.6, 1.45)
mesh = SubResource("BoxMesh_2")
surface_material_override/0 = SubResource("StandardMaterial3D_2")

[node name="Leg4" type="MeshInstance3D" parent="Desk"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 1.95, -0.6, 1.45)
mesh = SubResource("BoxMesh_2")
surface_material_override/0 = SubResource("StandardMaterial3D_2")

[node name="ThoughtBubble" type="Area3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 3, 0)
priority = 1

[node name="MeshInstance3D" type="MeshInstance3D" parent="ThoughtBubble"]
transform = Transform3D(1, 0, 0, 0, -1, 8.74228e-08, 0, -8.74228e-08, -1, 0, 0, 0)
mesh = SubResource("SphereMesh_1")
surface_material_override/0 = SubResource("StandardMaterial3D_5")

[node name="CollisionShape3D" type="CollisionShape3D" parent="ThoughtBubble"]
shape = SubResource("SphereShape3D_1")

[node name="Label3D" type="Label3D" parent="ThoughtBubble"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, -0.5, 0)
text = "Thought Cloud"
font_size = 64

[node name="Chair" type="Node3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 2)

[node name="Seat" type="MeshInstance3D" parent="Chair"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0.5, 0)
mesh = SubResource("BoxMesh_1")
surface_material_override/0 = SubResource("StandardMaterial3D_1")

[node name="Back" type="MeshInstance3D" parent="Chair"]
transform = Transform3D(1, 0, 0, 0, 0.965926, -0.258819, 0, 0.258819, 0.965926, 0, 1.1, -1.4)
mesh = SubResource("BoxMesh_1")
surface_material_override/0 = SubResource("StandardMaterial3D_1")

[node name="Leg1" type="MeshInstance3D" parent="Chair"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -1.95, 0, -1.45)
mesh = SubResource("BoxMesh_2")
surface_material_override/0 = SubResource("StandardMaterial3D_2")

[node name="Leg2" type="MeshInstance3D" parent="Chair"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 1.95, 0, -1.45)
mesh = SubResource("BoxMesh_2")
surface_material_override/0 = SubResource("StandardMaterial3D_2")

[node name="Leg3" type="MeshInstance3D" parent="Chair"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -1.95, 0, 1.45)
mesh = SubResource("BoxMesh_2")
surface_material_override/0 = SubResource("StandardMaterial3D_2")

[node name="Leg4" type="MeshInstance3D" parent="Chair"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 1.95, 0, 1.45)
mesh = SubResource("BoxMesh_2")
surface_material_override/0 = SubResource("StandardMaterial3D_2")

[node name="Camera3D" type="Camera3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 0.955337, 0.29552, 0, -0.29552, 0.955337, 0, 3, 8)

[node name="DirectionalLight3D" type="DirectionalLight3D" parent="."]
transform = Transform3D(0.146447, -0.853553, 0.5, 0.5, 0.5, 0.707107, -0.853553, 0.146446, 0.5, 0, 5, 0)
shadow_enabled = true

[node name="AmbientLight" type="Node3D" parent="."]

[node name="OmniLight3D" type="OmniLight3D" parent="AmbientLight"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 3, 0)
light_color = Color(0.8, 0.8, 0.8, 1)
light_energy = 0.5

[node name="UI" type="CanvasLayer" parent="."]

[node name="ThoughtModeButton" type="Button" parent="UI"]
offset_left = 20.0
offset_top = 20.0
offset_right = 280.0
offset_bottom = 70.0
theme_override_colors/font_hover_color = Color(0.8, 0.9, 1, 1)
theme_override_colors/font_color = Color(1, 1, 1, 1)
theme_override_colors/font_focus_color = Color(0.8, 0.9, 1, 1)
theme_override_font_sizes/font_size = 18
theme_override_styles/focus = SubResource("StyleBoxFlat_1")
theme_override_styles/hover = SubResource("StyleBoxFlat_1")
theme_override_styles/pressed = SubResource("StyleBoxFlat_1")
theme_override_styles/normal = SubResource("StyleBoxFlat_1")
text = "Enter Thought Cloud Mode"


```

File: C:/Users/Shad/Documents/tensigh-godot/Scripts/DeskRoom.cs
```csharp
using Godot;
using System;

namespace Tensigh
{
    public partial class DeskRoom : Node3D
    {
        private Camera3D _camera;
        private float _cameraSpeed = 2.0f;
        private float _cameraRotationSpeed = 1.0f;
        private float _cameraDistance = 8.0f;  // Increased initial distance
        private float _cameraHeight = 3.0f;    // Increased initial height
        private float _cameraAngle = -0.3f;    // Adjusted initial angle
        private bool _debugMode = true;
        private Label _debugLabel;
        private Area3D _thoughtBubble;
        private MeshInstance3D _bubbleMesh;
        private bool _isHoveringBubble = false;
        private Button _thoughtModeButton;
        private SceneManager _sceneManager;

        [Signal]
        public delegate void ThoughtSpaceActivatedEventHandler();

        public override void _Ready()
        {
            // Get SceneManager (it's an autoload)
            _sceneManager = GetNodeOrNull<SceneManager>("/root/SceneManager");

            if (_sceneManager == null)
            {
                GD.PrintErr("SceneManager autoload node not found in DeskRoom!");
            }
            else
            {
                GD.Print("SceneManager autoload found in DeskRoom.");
                // No initialization needed here as DeskRoom doesn't need to save state before switching
            }

            _camera = GetNode<Camera3D>("Camera3D");
            if (_camera == null)
            {
                GD.PrintErr("Camera not found in the scene!");
                return;
            }

            // Connect to the UI buttons
            _thoughtModeButton = GetNode<Button>("UI/ThoughtModeButton");
            if (_thoughtModeButton != null)
            {
                _thoughtModeButton.Pressed += ActivateThoughtSpace;
                GD.Print("ThoughtModeButton connected");
            }
            else
            {
                GD.PrintErr("ThoughtModeButton not found!");
            }

            // Setup thought bubble
            _thoughtBubble = GetNode<Area3D>("ThoughtBubble");
            if (_thoughtBubble == null)
            {
                GD.PrintErr("ThoughtBubble not found in the scene!");
                return;
            }
            
            _bubbleMesh = _thoughtBubble.GetNode<MeshInstance3D>("MeshInstance3D");
            
            // Connect signals
            _thoughtBubble.InputEvent += OnThoughtBubbleInputEvent;
            _thoughtBubble.MouseEntered += OnThoughtBubbleMouseEntered;
            _thoughtBubble.MouseExited += OnThoughtBubbleMouseExited;
            
            GD.Print("ThoughtBubble signals connected");

            // Create debug UI
            CreateDebugUI();

            // Set initial camera position
            UpdateCameraPosition();
            
            if (_debugMode)
            {
                GD.Print("DeskRoom scene initialized");
                GD.Print($"Initial camera position: {_camera.Position}");
                GD.Print($"Initial camera rotation: {_camera.Rotation}");
                GD.Print($"Initial camera angle: {_cameraAngle}");
                GD.Print($"Initial camera distance: {_cameraDistance}");
                GD.Print($"Initial camera height: {_cameraHeight}");
            }
        }

        private void OnThoughtBubbleInputEvent(Node camera, InputEvent @event, Vector3 position, Vector3 normal, long shapeIdx)
        {
            if (_debugMode) GD.Print($"ThoughtBubble input event: {@event}");
            
            if (@event is InputEventMouseButton mouseEvent)
            {
                if (_debugMode) GD.Print($"Mouse button: {mouseEvent.ButtonIndex}, Pressed: {mouseEvent.Pressed}");
                
                if (mouseEvent.ButtonIndex == MouseButton.Left && mouseEvent.Pressed)
                {
                    GD.Print("ThoughtBubble clicked!");
                    ActivateThoughtSpace();
                }
            }
        }

        private void OnThoughtBubbleMouseEntered()
        {
            GD.Print("Mouse entered ThoughtBubble");
            _isHoveringBubble = true;
            if (_bubbleMesh != null)
            {
                var material = (StandardMaterial3D)_bubbleMesh.GetSurfaceOverrideMaterial(0);
                if (material != null)
                {
                    material = (StandardMaterial3D)material.Duplicate();
                    material.EmissionEnabled = true;
                    material.Emission = new Color(0.5f, 0.7f, 1.0f);
                    material.EmissionEnergyMultiplier = 0.5f;
                    _bubbleMesh.SetSurfaceOverrideMaterial(0, material);
                }
            }
            
            Input.SetDefaultCursorShape(Input.CursorShape.PointingHand);
        }

        private void OnThoughtBubbleMouseExited()
        {
            GD.Print("Mouse exited ThoughtBubble");
            _isHoveringBubble = false;
            if (_bubbleMesh != null)
            {
                var material = (StandardMaterial3D)_bubbleMesh.GetSurfaceOverrideMaterial(0);
                if (material != null)
                {
                    material = (StandardMaterial3D)material.Duplicate();
                    material.EmissionEnabled = false;
                    _bubbleMesh.SetSurfaceOverrideMaterial(0, material);
                }
            }
            
            Input.SetDefaultCursorShape(Input.CursorShape.Arrow);
        }

        private void ActivateThoughtSpace()
        {
            // Create a confirmation label
            var canvasLayer = new CanvasLayer();
            AddChild(canvasLayer);
            
            var confirmationLabel = new Label
            {
                Text = "Entering Thought Space...",
                HorizontalAlignment = HorizontalAlignment.Center,
                VerticalAlignment = VerticalAlignment.Center,
                Position = new Vector2(GetViewport().GetVisibleRect().Size.X / 2 - 100, GetViewport().GetVisibleRect().Size.Y / 2 - 20),
                Size = new Vector2(200, 40)
            };
            
            canvasLayer.AddChild(confirmationLabel);
            
            // Wait a brief moment to show the transition message
            var timer = GetTree().CreateTimer(0.5);
            timer.Timeout += () => {
                // Load and switch to the ThoughtSpace scene USING SCENEMANAGER, checking for null
                if (IsInstanceValid(GetTree()) && _sceneManager != null)
                {
                    _sceneManager.ChangeScene("res://Scenes/ThoughtSpace.tscn"); 
                }
                else if (_sceneManager == null)
                {
                    GD.PrintErr("ActivateThoughtSpace: SceneManager is null, cannot change scene.");
                }
                // Remove the temporary label
                if (IsInstanceValid(canvasLayer))
                {
                    canvasLayer.QueueFree();
                }
            };
        }

        public override void _Input(InputEvent @event)
        {
            // Direct click check as a backup
            if (@event is InputEventMouseButton mouseEvent && mouseEvent.Pressed && mouseEvent.ButtonIndex == MouseButton.Left)
            {
                if (_isHoveringBubble)
                {
                    GD.Print("Direct click on bubble detected");
                    ActivateThoughtSpace();
                }
            }
        }

        private void CreateDebugUI()
        {
            var canvasLayer = new CanvasLayer();
            AddChild(canvasLayer);
            
            _debugLabel = new Label
            {
                Text = "DEBUG MODE",
                Position = new Vector2(10, 10),
                Size = new Vector2(400, 30),
                Modulate = new Color(1, 1, 1, 1)
            };
            canvasLayer.AddChild(_debugLabel);
        }

        public override void _Process(double delta)
        {
            if (_debugMode)
            {
                UpdateDebugUI();
            }
            
            // Update camera position based on mouse movement
            if (Input.IsMouseButtonPressed(MouseButton.Right))
            {
                var mouseMotion = Input.GetLastMouseVelocity();
                _cameraAngle += mouseMotion.X * _cameraRotationSpeed * (float)delta;
                _cameraDistance = Mathf.Clamp(_cameraDistance - mouseMotion.Y * 0.01f, 2.0f, 15.0f);
                UpdateCameraPosition();
            }
        }

        private void UpdateDebugUI()
        {
            if (_debugLabel != null && _camera != null)
            {
                _debugLabel.Text = $"Camera: {_camera.Position:F2}, {_camera.Rotation:F2}\n" +
                                  $"Angle: {_cameraAngle:F2}, Distance: {_cameraDistance:F2}, Height: {_cameraHeight:F2}\n" +
                                  $"Hovering: {_isHoveringBubble}";
            }
            else if (_debugLabel != null)
            {
                 _debugLabel.Text = "Camera not found or Debug Label error";
            }
        }

        private void UpdateCameraPosition()
        {
            if (_camera == null)
            {
                GD.PrintErr("UpdateCameraPosition called but _camera is null!");
                return;
            }

            // Calculate camera position based on angle and distance
            float x = _cameraDistance * Mathf.Sin(_cameraAngle);
            float z = _cameraDistance * Mathf.Cos(_cameraAngle);
            
            _camera.Position = new Vector3(x, _cameraHeight, z);
            _camera.LookAt(Vector3.Zero);
        }
        
        private void CleanupScene()
        {
            // Disconnect signals
            if (_thoughtBubble != null)
            {
                _thoughtBubble.InputEvent -= OnThoughtBubbleInputEvent;
                _thoughtBubble.MouseEntered -= OnThoughtBubbleMouseEntered;
                _thoughtBubble.MouseExited -= OnThoughtBubbleMouseExited;
            }
            
            // Clear references to help garbage collection
            _thoughtBubble = null;
            _bubbleMesh = null;
            _camera = null;
            _thoughtModeButton = null;
            
            // Force garbage collection
            System.GC.Collect();
            GD.Print("DeskRoom: Scene cleanup complete");
        }
        
        public override void _ExitTree()
        {
            // Clean up when the scene is being removed
            CleanupScene();
            base._ExitTree();
        }
    }
} 
```

File: C:/Users/Shad/Documents/tensigh-godot/Scripts/ThoughtSpaceUIManager.cs
```csharp
using Godot;
using System;
using System.IO; // Added for Path.GetDirectoryName

namespace Tensigh
{
    public class ThoughtSpaceUIManager
    {
        // Reference to the main ThoughtSpace node
        private ThoughtSpace _thoughtSpace;
        private PageManager _pageManager; // Dependency for page UI updates

        // UI Elements
        private Button _returnButton;
        private Button _loadDocumentButton;
        private Button _toggleWebViewerButton;
        private Button _prevPageButton;
        private Button _nextPageButton;
        private Button _newPageButton;
        private Label _pageLabel;
        private Label _coordinateLabel; // Dynamically created
        private Button _toggleBoundingBoxButton; // Dynamically created
        private Button _toggleRelationsButton; // Dynamically created

        // Actions/Events for UI interactions
        public event Action ReturnRequested;
        public event Action ToggleWebViewerRequested;
        public event Action NewPageRequested;
        public event Action PrevPageRequested;
        public event Action NextPageRequested;
        public event Action ToggleBoundingBoxesRequested;
        public event Action ToggleRelationsRequested;


        public void Initialize(ThoughtSpace thoughtSpace, PageManager pageManager)
        {
            _thoughtSpace = thoughtSpace ?? throw new ArgumentNullException(nameof(thoughtSpace));
            _pageManager = pageManager ?? throw new ArgumentNullException(nameof(pageManager));

            // Get Node references
            _returnButton = _thoughtSpace.GetNode<Button>("UI/ReturnButton");
            _loadDocumentButton = _thoughtSpace.GetNode<Button>("UI/LoadDocumentButton");
            _toggleWebViewerButton = _thoughtSpace.GetNode<Button>("UI/ToggleWebViewerButton");
            _prevPageButton = _thoughtSpace.GetNode<Button>("UI/PageNavigation/PrevPageButton");
            _nextPageButton = _thoughtSpace.GetNode<Button>("UI/PageNavigation/NextPageButton");
            _newPageButton = _thoughtSpace.GetNode<Button>("UI/PageNavigation/NewPageButton");
            _pageLabel = _thoughtSpace.GetNode<Label>("UI/PageNavigation/PageLabel");

            // Null checks
            if (_returnButton == null) GD.PrintErr("ReturnButton not found");
            if (_loadDocumentButton == null) GD.PrintErr("LoadDocumentButton not found");
            // Add null checks for other required buttons/labels...

            // Create dynamic UI elements
            CreateCoordinateLabel();
            CreateToggleButtons();


            // Connect signals to internal handlers
            ConnectSignals();

            // Initial UI state
            UpdatePageUI(); // Initial page label update
        }

        private void ConnectSignals()
        {
            _returnButton?.Connect("pressed", Callable.From(HandleReturnButtonPressed));
            _loadDocumentButton?.Connect("pressed", Callable.From(HandleLoadDocumentButtonPressed));
            _newPageButton?.Connect("pressed", Callable.From(HandleNewPageButtonPressed));
            _prevPageButton?.Connect("pressed", Callable.From(HandlePrevPageButtonPressed));
            _nextPageButton?.Connect("pressed", Callable.From(HandleNextPageButtonPressed));
            _toggleWebViewerButton?.Connect("pressed", Callable.From(HandleToggleWebViewerButtonPressed));
            _toggleBoundingBoxButton?.Connect("pressed", Callable.From(HandleToggleBoundingBoxesPressed));
            _toggleRelationsButton?.Connect("pressed", Callable.From(HandleToggleRelationsPressed));
        }

        // --- Dynamic UI Creation ---

        private void CreateCoordinateLabel()
        {
             _coordinateLabel = new Label
             {
                 Text = "Coordinates: (0, 0, 0)",
                 Position = new Vector2(20, _thoughtSpace.GetViewport().GetVisibleRect().Size.Y - 40),
                 Size = new Vector2(300, 30)
             };
             _thoughtSpace.AddChild(_coordinateLabel);
        }

        private void CreateToggleButtons()
        {
            // Add a bounding box toggle button
            _toggleBoundingBoxButton = new Button
            {
                Text = "Toggle Boxes",
                Position = new Vector2(20, _thoughtSpace.GetViewport().GetVisibleRect().Size.Y - 80),
                Size = new Vector2(120, 30)
            };
            _thoughtSpace.AddChild(_toggleBoundingBoxButton);

             // Add a relations toggle button
            _toggleRelationsButton = new Button
            {
                Text = "Toggle Relations",
                Position = new Vector2(150, _thoughtSpace.GetViewport().GetVisibleRect().Size.Y - 80),
                Size = new Vector2(120, 30)
            };
            _thoughtSpace.AddChild(_toggleRelationsButton);
        }

        // --- File Dialog Logic ---
        public void ShowLoadDocumentDialog()
        {
            var fileDialog = new FileDialog
            {
                Title = "Select a text document",
                FileMode = FileDialog.FileModeEnum.OpenFile,
                Access = FileDialog.AccessEnum.Filesystem,
                Filters = new string[] { "*.txt ; Text files" },
                CurrentDir = !string.IsNullOrEmpty(_pageManager?.LastOpenedPath) ? _pageManager.LastOpenedPath : OS.GetUserDataDir()
            };
            GD.Print($"UIManager: Opening file dialog at path: {fileDialog.CurrentDir}");

            // Connect signals within the UIManager
            fileDialog.FileSelected += (string path) => 
            {
                try
                {
                    // Call back to ThoughtSpace to perform the actual loading
                    _thoughtSpace.PerformLoadDocument(path); 
                    // UI update is now handled within PerformLoadDocument's call chain (LoadPageFromManager -> UpdatePageUI)
                }
                catch (Exception ex)
                {
                    GD.PrintErr($"UIManager: Error after file selection: {ex.Message}\n{ex.StackTrace}");
                }
                finally
                {
                    if (GodotObject.IsInstanceValid(fileDialog)) fileDialog.QueueFree();
                }
            };

            fileDialog.Canceled += () => 
            {
                if (GodotObject.IsInstanceValid(fileDialog)) fileDialog.QueueFree();
            };

            // Add the dialog to the main ThoughtSpace node
            _thoughtSpace.AddChild(fileDialog);
            fileDialog.PopupCentered(new Vector2I(800, 600));
        }

        // --- Internal Signal Handlers ---

        private void HandleReturnButtonPressed() => ReturnRequested?.Invoke();
        private void HandleLoadDocumentButtonPressed() => ShowLoadDocumentDialog();
        private void HandleToggleWebViewerButtonPressed() => ToggleWebViewerRequested?.Invoke();
        private void HandleNewPageButtonPressed() => NewPageRequested?.Invoke();
        private void HandlePrevPageButtonPressed() => PrevPageRequested?.Invoke();
        private void HandleNextPageButtonPressed() => NextPageRequested?.Invoke();
        private void HandleToggleBoundingBoxesPressed() => ToggleBoundingBoxesRequested?.Invoke();
        private void HandleToggleRelationsPressed() => ToggleRelationsRequested?.Invoke();


        // --- Public Methods for Updating UI ---

        public void UpdatePageUI()
        {
             if (_pageLabel != null && _pageManager != null)
             {
                 var currentPage = _pageManager.GetCurrentPage();
                 if (currentPage != null)
                 {
                     _pageLabel.Text = $"{currentPage.Name} ({_pageManager.CurrentPageIndex + 1}/{_pageManager.Pages.Count})";
                 }
                 else
                 {
                     _pageLabel.Text = "No Pages";
                 }
             }

             // Update button states
             if (_prevPageButton != null && _pageManager != null)
                 _prevPageButton.Disabled = _pageManager.CurrentPageIndex <= 0;

             if (_nextPageButton != null && _pageManager != null)
                 _nextPageButton.Disabled = _pageManager.CurrentPageIndex >= _pageManager.Pages.Count - 1;
        }

        public void SetCoordinateLabelText(string text)
        {
            if (_coordinateLabel != null)
            {
                _coordinateLabel.Text = text;
            }
        }

        public void UpdateWebViewerToggleText(bool isWebViewerVisible)
        {
             if (_toggleWebViewerButton != null)
             {
                 _toggleWebViewerButton.Text = isWebViewerVisible ? "Hide Browser" : "Show Browser";
             }
        }

        public void Cleanup()
        {
             // Optional: Disconnect signals
            _returnButton?.Disconnect("pressed", Callable.From(HandleReturnButtonPressed));
            _loadDocumentButton?.Disconnect("pressed", Callable.From(HandleLoadDocumentButtonPressed));
            _newPageButton?.Disconnect("pressed", Callable.From(HandleNewPageButtonPressed));
            _prevPageButton?.Disconnect("pressed", Callable.From(HandlePrevPageButtonPressed));
            _nextPageButton?.Disconnect("pressed", Callable.From(HandleNextPageButtonPressed));
            _toggleWebViewerButton?.Disconnect("pressed", Callable.From(HandleToggleWebViewerButtonPressed));
            _toggleBoundingBoxButton?.Disconnect("pressed", Callable.From(HandleToggleBoundingBoxesPressed));
            _toggleRelationsButton?.Disconnect("pressed", Callable.From(HandleToggleRelationsPressed));

            // Dynamically created nodes are children of ThoughtSpace and will be freed with it.
        }
    }
} 
```

File: C:/Users/Shad/Documents/tensigh-godot/Scenes/ThoughtSpace.tscn
```tscn
[gd_scene load_steps=5 format=3 uid="uid://kqf61g6nywe3"]

[ext_resource type="Script" path="res://Scripts/ThoughtSpace.cs" id="1_ygxd1"]

[sub_resource type="Environment" id="Environment_1"]
background_mode = 1
background_color = Color(0.0, 0.05, 0.1, 1.0)
ambient_light_source = 2
ambient_light_color = Color(0.2, 0.3, 0.5, 1.0)
tonemap_mode = 2
glow_enabled = false
glow_bloom = 0.2
glow_blend_mode = 0
fog_enabled = true
fog_light_color = Color(0.1, 0.2, 0.3, 1.0)
fog_density = 0.001
fog_sky_affect = 0.05
volumetric_fog_enabled = true
volumetric_fog_density = 0.005

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_1"]
bg_color = Color(0.0, 0.2, 0.4, 0.8)
border_width_left = 2
border_width_top = 2
border_width_right = 2
border_width_bottom = 2
border_color = Color(0.4, 0.6, 0.8, 1)
corner_radius_top_left = 8
corner_radius_top_right = 8
corner_radius_bottom_right = 8
corner_radius_bottom_left = 8
shadow_size = 2
shadow_offset = Vector2(2, 2)

[node name="ThoughtSpace" type="Node3D"]
script = ExtResource("1_ygxd1")

[node name="WorldEnvironment" type="WorldEnvironment" parent="."]
environment = SubResource("Environment_1")

[node name="Camera3D" type="Camera3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 2)

[node name="DirectionalLight3D" type="DirectionalLight3D" parent="."]
transform = Transform3D(0.866025, -0.25, 0.433013, 0, 0.866025, 0.5, -0.5, -0.433013, 0.75, 0, 5, 0)
shadow_enabled = true

[node name="TextContainer" type="Node3D" parent="."]

[node name="UI" type="CanvasLayer" parent="."]

[node name="ReturnButton" type="Button" parent="UI"]
offset_left = 20.0
offset_top = 20.0
offset_right = 180.0
offset_bottom = 60.0
theme_override_colors/font_color = Color(1, 1, 1, 1)
theme_override_colors/font_hover_color = Color(0.8, 0.9, 1, 1)
theme_override_styles/normal = SubResource("StyleBoxFlat_1")
theme_override_styles/hover = SubResource("StyleBoxFlat_1")
theme_override_styles/pressed = SubResource("StyleBoxFlat_1")
theme_override_styles/focus = SubResource("StyleBoxFlat_1")
text = "Return to Desk"

[node name="LoadDocumentButton" type="Button" parent="UI"]
offset_left = 200.0
offset_top = 20.0
offset_right = 380.0
offset_bottom = 60.0
theme_override_colors/font_color = Color(1, 1, 1, 1)
theme_override_colors/font_hover_color = Color(0.8, 0.9, 1, 1)
theme_override_styles/normal = SubResource("StyleBoxFlat_1")
theme_override_styles/hover = SubResource("StyleBoxFlat_1")
theme_override_styles/pressed = SubResource("StyleBoxFlat_1")
theme_override_styles/focus = SubResource("StyleBoxFlat_1")
text = "Load Document"

[node name="ToggleWebViewerButton" type="Button" parent="UI"]
offset_left = 400.0
offset_top = 20.0
offset_right = 580.0
offset_bottom = 60.0
theme_override_colors/font_color = Color(1, 1, 1, 1)
theme_override_colors/font_hover_color = Color(0.8, 0.9, 1, 1)
theme_override_styles/normal = SubResource("StyleBoxFlat_1")
theme_override_styles/hover = SubResource("StyleBoxFlat_1")
theme_override_styles/pressed = SubResource("StyleBoxFlat_1")
theme_override_styles/focus = SubResource("StyleBoxFlat_1")
text = "Toggle Browser"

[node name="PageNavigation" type="HBoxContainer" parent="UI"]
offset_left = 20.0
offset_top = 70.0
offset_right = 380.0
offset_bottom = 110.0
theme_override_constants/separation = 10

[node name="PrevPageButton" type="Button" parent="UI/PageNavigation"]
custom_minimum_size = Vector2(40, 40)
theme_override_colors/font_color = Color(1, 1, 1, 1)
theme_override_colors/font_hover_color = Color(0.8, 0.9, 1, 1)
theme_override_styles/normal = SubResource("StyleBoxFlat_1")
theme_override_styles/hover = SubResource("StyleBoxFlat_1")
theme_override_styles/pressed = SubResource("StyleBoxFlat_1")
theme_override_styles/focus = SubResource("StyleBoxFlat_1")
text = "<"

[node name="PageLabel" type="Label" parent="UI/PageNavigation"]
layout_mode = 2
theme_override_colors/font_color = Color(0.8, 0.9, 1, 1)
text = "Page 1 (1/1)"
horizontal_alignment = 1
vertical_alignment = 1

[node name="NextPageButton" type="Button" parent="UI/PageNavigation"]
custom_minimum_size = Vector2(40, 40)
theme_override_colors/font_color = Color(1, 1, 1, 1)
theme_override_colors/font_hover_color = Color(0.8, 0.9, 1, 1)
theme_override_styles/normal = SubResource("StyleBoxFlat_1")
theme_override_styles/hover = SubResource("StyleBoxFlat_1")
theme_override_styles/pressed = SubResource("StyleBoxFlat_1")
theme_override_styles/focus = SubResource("StyleBoxFlat_1")
text = ">"

[node name="NewPageButton" type="Button" parent="UI/PageNavigation"]
layout_mode = 2
theme_override_colors/font_color = Color(1, 1, 1, 1)
theme_override_colors/font_hover_color = Color(0.8, 0.9, 1, 1)
theme_override_styles/normal = SubResource("StyleBoxFlat_1")
theme_override_styles/hover = SubResource("StyleBoxFlat_1")
theme_override_styles/pressed = SubResource("StyleBoxFlat_1")
theme_override_styles/focus = SubResource("StyleBoxFlat_1")
text = "New Page"

[node name="Instructions" type="Label" parent="UI"]
offset_left = 21.0
offset_top = 120.0
offset_right = 309.0
offset_bottom = 198.0
theme_override_colors/font_color = Color(0.8, 0.9, 1, 1)
text = "ESC: Toggle edit mode
Left-click and drag: Move camera
Mouse wheel: Zoom in/out
Right-click: Reset view"
vertical_alignment = 1
```

File: C:/Users/Shad/Documents/tensigh-godot/.godot/mono/temp/obj/project.assets.json
```json
{
  "version": 3,
  "targets": {
    "net8.0": {
      "Godot.SourceGenerators/4.4.1": {
        "type": "package",
        "build": {
          "build/Godot.SourceGenerators.props": {}
        }
      },
      "GodotSharp/4.4.1": {
        "type": "package",
        "compile": {
          "lib/net8.0/GodotSharp.dll": {
            "related": ".xml"
          }
        },
        "runtime": {
          "lib/net8.0/GodotSharp.dll": {
            "related": ".xml"
          }
        }
      },
      "GodotSharpEditor/4.4.1": {
        "type": "package",
        "dependencies": {
          "GodotSharp": "4.4.1"
        },
        "compile": {
          "lib/net8.0/GodotSharpEditor.dll": {
            "related": ".xml"
          }
        },
        "runtime": {
          "lib/net8.0/GodotSharpEditor.dll": {
            "related": ".xml"
          }
        }
      }
    }
  },
  "libraries": {
    "Godot.SourceGenerators/4.4.1": {
      "sha512": "V/cuX41BxippWGD79zrP2bhqfXkuyiy9OFuCkTu3flo7I6STSJca637TL2phe7rzROIFre0vQR1+PAMdsjO3zg==",
      "type": "package",
      "path": "godot.sourcegenerators/4.4.1",
      "files": [
        ".nupkg.metadata",
        ".signature.p7s",
        "analyzers/dotnet/cs/Godot.SourceGenerators.dll",
        "build/Godot.SourceGenerators.props",
        "godot.sourcegenerators.4.4.1.nupkg.sha512",
        "godot.sourcegenerators.nuspec"
      ]
    },
    "GodotSharp/4.4.1": {
      "sha512": "ghnQEo5LikQPfbCYcVxje8epffNCiyNG4zvGWUDRZRC1O+653+yqG3wdxk3+5RZsA3jaRuGKRavsGcnhLKe12g==",
      "type": "package",
      "path": "godotsharp/4.4.1",
      "files": [
        ".nupkg.metadata",
        ".signature.p7s",
        "godotsharp.4.4.1.nupkg.sha512",
        "godotsharp.nuspec",
        "lib/net8.0/GodotSharp.dll",
        "lib/net8.0/GodotSharp.xml"
      ]
    },
    "GodotSharpEditor/4.4.1": {
      "sha512": "cc3nA24r/sjW8KxrNqfSQk4CQMQYcg/kYk5935R88IhGBdRuTH4miaBXPlzR/td5GR8i1oGtCMWyW8axpQ0DxA==",
      "type": "package",
      "path": "godotsharpeditor/4.4.1",
      "files": [
        ".nupkg.metadata",
        ".signature.p7s",
        "godotsharpeditor.4.4.1.nupkg.sha512",
        "godotsharpeditor.nuspec",
        "lib/net8.0/GodotSharpEditor.dll",
        "lib/net8.0/GodotSharpEditor.xml"
      ]
    }
  },
  "projectFileDependencyGroups": {
    "net8.0": [
      "Godot.SourceGenerators >= 4.4.1",
      "GodotSharp >= 4.4.1",
      "GodotSharpEditor >= 4.4.1"
    ]
  },
  "packageFolders": {
    "C:\\Users\\Shad\\.nuget\\packages\\": {},
    "C:\\Program Files (x86)\\Microsoft Visual Studio\\Shared\\NuGetPackages": {}
  },
  "project": {
    "version": "1.0.0",
    "restore": {
      "projectUniqueName": "C:\\Users\\Shad\\Documents\\tensigh-godot\\Tensigh.csproj",
      "projectName": "Tensigh",
      "projectPath": "C:\\Users\\Shad\\Documents\\tensigh-godot\\Tensigh.csproj",
      "packagesPath": "C:\\Users\\Shad\\.nuget\\packages\\",
      "outputPath": "C:\\Users\\Shad\\Documents\\tensigh-godot\\.godot\\mono\\temp\\obj\\",
      "projectStyle": "PackageReference",
      "fallbackFolders": [
        "C:\\Program Files (x86)\\Microsoft Visual Studio\\Shared\\NuGetPackages"
      ],
      "configFilePaths": [
        "C:\\Users\\Shad\\AppData\\Roaming\\NuGet\\NuGet.Config",
        "C:\\Program Files (x86)\\NuGet\\Config\\Microsoft.VisualStudio.FallbackLocation.config",
        "C:\\Program Files (x86)\\NuGet\\Config\\Microsoft.VisualStudio.Offline.config"
      ],
      "originalTargetFrameworks": [
        "net8.0"
      ],
      "sources": {
        "C:\\Program Files (x86)\\Microsoft SDKs\\NuGetPackages\\": {},
        "https://api.nuget.org/v3/index.json": {}
      },
      "frameworks": {
        "net8.0": {
          "targetAlias": "net8.0",
          "projectReferences": {}
        }
      },
      "warningProperties": {
        "warnAsError": [
          "NU1605"
        ]
      },
      "restoreAuditProperties": {
        "enableAudit": "true",
        "auditLevel": "low",
        "auditMode": "direct"
      },
      "SdkAnalysisLevel": "9.0.200"
    },
    "frameworks": {
      "net8.0": {
        "targetAlias": "net8.0",
        "dependencies": {
          "Godot.SourceGenerators": {
            "target": "Package",
            "version": "[4.4.1, )"
          },
          "GodotSharp": {
            "target": "Package",
            "version": "[4.4.1, )"
          },
          "GodotSharpEditor": {
            "target": "Package",
            "version": "[4.4.1, )"
          }
        },
        "imports": [
          "net461",
          "net462",
          "net47",
          "net471",
          "net472",
          "net48",
          "net481"
        ],
        "assetTargetFallback": true,
        "warn": true,
        "frameworkReferences": {
          "Microsoft.NETCore.App": {
            "privateAssets": "all"
          }
        },
        "runtimeIdentifierGraphPath": "C:\\Program Files\\dotnet\\sdk\\9.0.202/PortableRuntimeIdentifierGraph.json"
      }
    }
  }
}
```

File: C:/Users/Shad/Documents/tensigh-godot/Scripts/WebViewer.cs
```csharp
using Godot;
using System;
using System.Collections.Generic;

public partial class WebViewer : Control
{
    private GDScript _wrapperScript;
    private Node _wrapper;
    private TextureRect _textureRect;
    private bool _isInitialized = false;

    public override void _Ready()
    {
        GD.PrintErr("WebViewer _Ready");
        // Create TextureRect for the browser content
        _textureRect = new TextureRect();
        _textureRect.CustomMinimumSize = new Vector2(1024, 768);
        _textureRect.ExpandMode = TextureRect.ExpandModeEnum.IgnoreSize;
        _textureRect.StretchMode = TextureRect.StretchModeEnum.Keep;
        AddChild(_textureRect);

        // Load the GDScript wrapper
        GD.PrintErr("trying to loadGDCefWrapper.gd");
        _wrapperScript = GD.Load<GDScript>("res://Scripts/GDCefWrapper.gd");
        if (_wrapperScript == null)
        {
            GD.PrintErr("Failed to load GDCefWrapper.gd");
            return;
        }

        // Create the wrapper instance
        _wrapper = _wrapperScript.New().As<Node>();
        if (_wrapper == null)
        {
            GD.PrintErr("Failed to create GDCefWrapper instance");
            return;
        }
        GD.PrintErr("adding as a child GDCefWrapper.gd");
        AddChild(_wrapper);

        // Connect signals
        _wrapper.Connect("browser_paint", Callable.From<Texture2D>(OnBrowserPaint));
        _wrapper.Connect("page_loaded", Callable.From<string>(OnPageLoaded));
        _wrapper.Connect("page_failed_loading", Callable.From<int, string>(OnPageFailedLoading));
        _wrapper.Connect("download_updated", Callable.From<string, float>(OnDownloadUpdated));

        // Initialize CEF
        var config = new Godot.Collections.Dictionary<string, Variant>
        {
            { "log_severity", "warning" },
            { "enable_media_stream", false },
            { "remote_debugging_port", 7777 },
            { "incognito", true },
            { "javascript", true },
            { "webgl", true },
            { "locale", "en-US" }
        };

        // Create browser
        var settings = new Godot.Collections.Dictionary<string, Variant>
        {
            { "frame_rate", 60 },
            { "javascript", true },
            { "image_loading", true },
            { "webgl", true },
            { "enable_ad_block", true },
            { "allow_downloads", true },
            { "download_folder", "user://" },
            { "user_gesture_required", false }
        };
        var browserResult = _wrapper.Call("create_browser", "https://www.google.com", _textureRect, settings);
        if (browserResult.VariantType == Variant.Type.Nil)
        {
            GD.PrintErr("Failed to create browser: ", _wrapper.Call("get_error"));
            return;
        }
        
        _isInitialized = true;
        GD.Print("WebViewer initialized successfully");
    }

    public override void _ExitTree()
    {
        CleanupResources();
    }

    public void CleanupResources()
    {
        GD.Print("WebViewer: Cleaning up resources");
        
        // First shutdown the wrapper/browser if available
        if (_wrapper != null)
        {
            try
            {
                // Call shutdown on the wrapper which should clean up CEF resources
                _wrapper.Call("shutdown");
                
                // Disconnect all signals from the wrapper
                foreach (var signalName in new[] { "browser_paint", "page_loaded", "page_failed_loading", "download_updated" })
                {
                    if (_wrapper.HasSignal(signalName) && _wrapper.IsConnected(signalName, new Callable(this, "On" + signalName.Substring(0, 1).ToUpper() + signalName.Substring(1))))
                    {
                        _wrapper.Disconnect(signalName, new Callable(this, "On" + signalName.Substring(0, 1).ToUpper() + signalName.Substring(1)));
                    }
                }
                
                // Queue the wrapper for deletion
                if (_wrapper.IsInsideTree())
                {
                    _wrapper.QueueFree();
                }
            }
            catch (Exception ex)
            {
                GD.PrintErr($"Error during wrapper cleanup: {ex.Message}");
            }
            
            _wrapper = null;
        }
        
        // Clean up texture rect
        if (_textureRect != null)
        {
            if (_textureRect.Texture != null)
            {
                // Clear the texture reference
                _textureRect.Texture = null;
            }
            
            if (_textureRect.IsInsideTree())
            {
                _textureRect.QueueFree();
            }
            
            _textureRect = null;
        }
        
        // Clear script reference
        _wrapperScript = null;
        
        // Force garbage collection
        GC.Collect();
        GC.WaitForPendingFinalizers();
        
        GD.Print("WebViewer: Resources cleaned up");
    }

    private void OnBrowserPaint(Texture2D texture)
    {
        _textureRect.Texture = texture;
    }

    private void OnPageLoaded(string url)
    {
        GD.Print("Page loaded: ", url);
    }

    private void OnPageFailedLoading(int errCode, string errMsg)
    {
        GD.PrintErr("Page failed to load: ", errMsg, " (Error code: ", errCode, ")");
    }

    private void OnDownloadUpdated(string file, float percentage)
    {
        GD.Print("Downloading ", file, ": ", percentage, "%");
    }

    public void LoadUrl(string url)
    {
        if (_wrapper != null)
        {
            _wrapper.Call("load_url", url);
        }
    }

    public void SetZoomLevel(float delta)
    {
        if (_wrapper != null)
        {
            _wrapper.Call("set_zoom_level", delta);
        }
    }

    public void EnableAdBlock(bool enable)
    {
        if (_wrapper != null)
        {
            _wrapper.Call("enable_ad_block", enable);
        }
    }

    public void AddAdBlockPattern(string pattern)
    {
        if (_wrapper != null)
        {
            _wrapper.Call("add_ad_block_pattern", pattern);
        }
    }

    public void SetAudioMuted(bool mute)
    {
        if (_wrapper != null)
        {
            _wrapper.Call("set_audio_muted", mute);
        }
    }
} 
```

File: C:/Users/Shad/Documents/tensigh-godot/Scripts/CameraController.cs
```csharp
#nullable enable
using Godot;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Tensigh
{
    public partial class CameraController : Node
    {
        private Camera3D? _cameraNode;
        private Vector3 _offset = Vector3.Zero;
        private float _zoomSpeed = 0.5f;
        private float _panSpeed = 0.01f;

        // Event to notify when the camera's transform (position/rotation) changes
        public event Action<Vector3, Vector3>? CameraTransformChanged; // Marked as nullable

        /// <summary>
        /// Initializes the controller with the necessary camera node and settings.
        /// </summary>
        /// <param name="cameraNode">The Camera3D node to control.</param>
        /// <param name="initialOffset">The initial position offset (Z controls distance).</param>
        /// <param name="zoomSpeed">Sensitivity of the mouse wheel zoom.</param>
        /// <param name="panSpeed">Sensitivity of the mouse drag panning.</param>
        public void Initialize(Camera3D cameraNode, Vector3 initialOffset, float zoomSpeed = 0.5f, float panSpeed = 0.01f)
        {
            _cameraNode = cameraNode ?? throw new ArgumentNullException(nameof(cameraNode));
            _offset = initialOffset;
            _zoomSpeed = zoomSpeed;
            _panSpeed = panSpeed;
            // Apply initial transform and notify listeners
            UpdateCameraTransform(true); // Force initial notification
        }

        /// <summary>
        /// Moves the camera parallel to the view plane based on screen delta.
        /// </summary>
        /// <param name="screenDelta">The change in screen coordinates from mouse movement.</param>
        public void Pan(Vector2 screenDelta)
        {
            if (_cameraNode == null) return;

            // Use camera's global basis vectors for panning parallel to the view plane
            var right = _cameraNode.GlobalTransform.Basis.X;
            // Note: We use the global Y-axis for vertical panning relative to the world,
            // assuming the camera looks mostly forward and isn't rolled.
            // If complex camera rotations are needed later, this might need adjustment.
            var worldUp = Vector3.Up;

            // Calculate world movement
            // Horizontal pan: Inverted delta.X (screen right moves camera left relative to view)
            // Vertical pan: Non-inverted delta.Y (screen down moves camera up)
            Vector3 worldMovement = (right * -screenDelta.X * _panSpeed) + (worldUp * screenDelta.Y * _panSpeed);

            // Update the offset's X and Y, keeping Z the same
            _offset.X += worldMovement.X;
            _offset.Y += worldMovement.Y; // Allow Y panning

            UpdateCameraTransform();
        }

        /// <summary>
        /// Adjusts the camera's distance (Z offset) based on zoom input.
        /// </summary>
        /// <param name="zoomAmount">Typically -1 for zoom in (wheel up), 1 for zoom out (wheel down).</param>
        public void Zoom(float zoomAmount)
        {
            if (_cameraNode == null) return;

            _offset.Z += zoomAmount * _zoomSpeed;
            _offset.Z = Mathf.Clamp(_offset.Z, 1.0f, 20.0f); // Clamp zoom distance (min 1, max 20)

            UpdateCameraTransform();
        }

        /// <summary>
        /// Resets the camera's XY position, optionally centering on target positions, while maintaining Z distance.
        /// </summary>
        /// <param name="targetPositions">Optional enumeration of world positions to center on.</param>
        public void Reset(IEnumerable<Vector3>? targetPositions = null)
        {
            if (_cameraNode == null) return;

            if (targetPositions != null && targetPositions.Any())
            {
                Vector3 center = Vector3.Zero;
                int count = 0;
                foreach (var pos in targetPositions)
                {
                    center += pos;
                    count++;
                }
                if (count > 0)
                {
                    center /= count;
                }
                // Reset offset X/Y to center X/Y, keep existing Z offset
                _offset.X = center.X;
                _offset.Y = center.Y;
            }
            else
            {
                // Reset offset to origin X/Y, keep existing Z offset
                _offset.X = 0;
                _offset.Y = 0;
            }

            UpdateCameraTransform();
        }

        /// <summary>
        /// Applies the current offset to the camera node's position and ensures zero rotation.
        /// Notifies listeners if the transform changed or if forceNotify is true.
        /// </summary>
        /// <param name="forceNotify">Force notification even if position/rotation didn't change numerically.</param>
        private void UpdateCameraTransform(bool forceNotify = false)
        {
            if (_cameraNode == null) return;

            var oldPosition = _cameraNode.Position;
            var oldRotation = _cameraNode.Rotation;

            // Apply the offset. Camera directly positioned based on offset.
            // Maintain zero rotation (looking straight ahead).
            _cameraNode.Position = _offset;
            _cameraNode.Rotation = Vector3.Zero;

            // Notify listeners only if the transform actually changed or forced
            if (forceNotify || _cameraNode.Position != oldPosition || _cameraNode.Rotation != oldRotation)
            {
                CameraTransformChanged?.Invoke(_cameraNode.Position, _cameraNode.Rotation);
            }
        }

        // --- Accessors ---

        /// <summary>
        /// Gets the controlled Camera3D node.
        /// Returns null if not initialized.
        /// </summary>
        public Camera3D? GetCameraNode() => _cameraNode;

        /// <summary>
        /// Gets the current world position of the camera.
        /// Returns Vector3.Zero if not initialized.
        /// </summary>
        public Vector3 GetPosition() => _cameraNode?.Position ?? Vector3.Zero;

        /// <summary>
        /// Gets the current world rotation of the camera (Euler angles).
        /// Returns Vector3.Zero if not initialized.
        /// </summary>
        public Vector3 GetRotation() => _cameraNode?.Rotation ?? Vector3.Zero;
    }
} 
```

File: C:/Users/Shad/Documents/tensigh-godot/tensigh.md
```markdown
# Tensigh: 3D Thought Organization System

## Overview

Tensigh is a 3D thought organization and visualization tool built with Godot 4.x using C#. It allows users to create, edit, and organize text blocks in 3D space, establish relationships between them, analyze text content, and integrate web content.

## Core Classes

### ThoughtSpace

The main Node3D class that serves as the central controller for the 3D environment.

**Key Responsibilities:**
- 3D scene management and rendering
- Text block creation and manipulation
- Camera control and navigation
- Input handling (mouse, keyboard)
- Relation visualization
- UI integration
- File operations (save/load)
- Text analysis features

**Key Methods:**
- `_Ready()`: Initializes the 3D environment, UI elements, and resources
- `_Process(double delta)`: Handles per-frame updates, cursor blinking, and animations
- `_Input(InputEvent @event)`: Processes user input for text editing and navigation
- `CreateNewTextBlock()`: Creates text blocks in 3D space
- `UpdateTextDisplay()`: Updates visual representation of text blocks
- `SaveText()` / `LoadText()`: Handles file persistence
- `HandleRelationMode()`: Manages relationship visualization between blocks

### TextBlock

Represents a single block of text in 3D space.

**Properties:**
- `Id`: Unique identifier (GUID)
- `Text`: The actual text content
- `Position`: 3D position in space
- `Scale`: 3D scale
- `Relations`: List of connections to other blocks
- `Label`: Reference to the Label3D node
- `IsEditing`: Whether the block is currently being edited
- `IsHovered`: Whether the mouse is hovering over the block
- `TextColor`: Color of the text
- `BoundingBox`: Visual representation of the block's boundaries

**Key Methods:**
- `UpdateTextDisplay()`: Updates the visual appearance of the text
- `TextBlock(string text, Vector3 position)`: Constructor for creating new text blocks

### Relation

Defines a connection between two TextBlocks.

**Properties:**
- `SourceId`: ID of the source TextBlock
- `TargetId`: ID of the target TextBlock
- `Label`: Description of the relationship
- `VisualLabel`: 3D label for visualizing the relation

### TextBlockCollection

Organizes TextBlocks into pages.

**Properties:**
- `Blocks`: List of TextBlock objects
- `Relations`: List of Relation objects
- `Name`: Name of the page

### PageManager

Manages multiple pages of TextBlockCollections.

**Properties:**
- `Pages`: List of TextBlockCollection objects
- `CurrentPageIndex`: Index of the active page
- `CameraSettings`: Camera position and rotation for each page
- `LastOpenedPath`: Path of the last opened file

**Key Methods:**
- `AddPage()`: Creates a new page
- `RemovePage()`: Deletes a page
- `SwitchToPage()`: Changes the active page
- `GetCurrentPage()`: Returns the current TextBlockCollection

### WebViewerManager

Integrates web content viewing capabilities.

**Features:**
- Web page display within the application
- URL handling and navigation
- Integration with the ThoughtSpace UI

### NLPService

Provides natural language processing features.

**Features:**
- Keyword extraction
- Sentiment analysis
- Topic identification
- Text evaluation

## Key Features

### 3D Text Visualization
- Text blocks represented as 3D objects
- Scalable and movable text elements
- Custom bounding boxes
- Cursor and editing capabilities

### Relation Management
- Create semantic connections between blocks
- Visualize relationships with 3D lines and labels
- Orbit visualization for related blocks
- Relation filtering and highlighting

### Text Analysis
- Highlight keywords in text
- Color coding based on sentiment
- Topic identification and grouping
- Analysis panel with detailed results

### Multi-page Organization
- Create multiple pages of thought spaces
- Navigation between pages
- Per-page camera settings
- Page naming and organization

### Persistence
- JSON serialization and deserialization
- Custom converters for Godot types
- Automatic saving and recovery
- Document import/export

### Camera Controls
- 3D navigation with rotation and zoom
- Pan and tilt controls
- Camera position memory per page
- Reset and center functions

### Web Integration
- Web page viewing within the application
- Toggle web viewer visibility
- URL handling

## Implementation Details

### Resource Management
- Shared resources for performance optimization
- Proper disposal of resources (IDisposable implementation)
- Memory optimization with pooled objects
- Custom BoxMesh and StandardMaterial3D usage

### Visual Effects
- Smooth transitions between states
- Cursor blinking in edit mode
- Fade effects for relation visualization
- Dynamic text scaling and formatting

### Input Handling
- Text editing with cursor positioning
- Camera navigation via mouse and keyboard
- Block selection and manipulation
- Relation creation with source/target selection

### Serialization
- Custom Vector3Converter for Godot Vector3 serialization
- JSON property naming with JsonPropertyName attributes
- Selective serialization with JsonIgnore
- Clean separation of visual and data components

## Usage Flow

1. Create text blocks in 3D space
2. Edit and position text blocks
3. Create relationships between related blocks
4. Organize content across multiple pages
5. Analyze text for insights
6. Integrate web content as needed
7. Save and load projects

## Extensions and Integration

The system is designed to be extensible, with clean separation between:
- Data models (TextBlock, Relation)
- Visual representation (Label3D, MeshInstance3D)
- Control logic (ThoughtSpace)
- Helper services (NLPService, WebViewerManager)

This architecture allows for easy addition of new features or integration with other systems. 
```

File: C:/Users/Shad/Documents/tensigh-godot/Scripts/ErrorHandler.cs
```csharp
using Godot;
using System;
using System.Collections.Generic;

public partial class ErrorHandler : Node
{
    // Singleton instance
    private static ErrorHandler _instance;
    public static ErrorHandler Instance
    {
        get
        {
            if (_instance == null)
            {
                // Create a new instance if it doesn't exist
                var node = new Node();
                _instance = new ErrorHandler();
                node.AddChild(_instance);
                node.Name = "ErrorHandler";
                // Add to the scene tree
                var sceneTree = Engine.GetMainLoop() as SceneTree;
                if (sceneTree != null)
                {
                    var root = sceneTree.Root;
                    root.AddChild(node);
                }
            }
            return _instance;
        }
    }

    // Event for when a new error is logged
    public event Action<ErrorInfo> OnErrorLogged;

    // List to store recent errors
    private List<ErrorInfo> _recentErrors = new List<ErrorInfo>();
    private const int MaxStoredErrors = 100;

    // Error severity levels
    public enum ErrorSeverity
    {
        Info,
        Warning,
        Error,
        Critical
    }

    // Class to store error information
    public class ErrorInfo
    {
        public string Message { get; set; }
        public ErrorSeverity Severity { get; set; }
        public string Source { get; set; }
        public DateTime Timestamp { get; set; }
        public string StackTrace { get; set; }

        public ErrorInfo(string message, ErrorSeverity severity, string source, string stackTrace = null)
        {
            Message = message;
            Severity = severity;
            Source = source;
            Timestamp = DateTime.Now;
            StackTrace = stackTrace;
        }

        public override string ToString()
        {
            return $"[{Timestamp:HH:mm:ss}] [{Severity}] [{Source}] {Message}";
        }
    }

    // Error log file path
    private string _logFilePath;

    // Initialize the error handler
    public override void _Ready()
    {
        // Set up log file path
        _logFilePath = OS.GetUserDataDir() + "/error_log.txt";
        
        // Log that the error handler is initialized
        LogInfo("Error handler initialized", "ErrorHandler");
    }

    // Clean up when the node is removed
    public override void _ExitTree()
    {
        // No need to disconnect from Engine.PrintError as it's not available in Godot 4.x
    }

    // Public methods to log errors
    public void LogInfo(string message, string source = "Application")
    {
        LogError(message, ErrorSeverity.Info, source);
    }

    public void LogWarning(string message, string source = "Application")
    {
        LogError(message, ErrorSeverity.Warning, source);
    }

    public void LogError(string message, string source = "Application")
    {
        LogError(message, ErrorSeverity.Error, source);
    }

    public void LogCritical(string message, string source = "Application")
    {
        LogError(message, ErrorSeverity.Critical, source);
    }

    // Main method to log errors
    public void LogError(string message, ErrorSeverity severity, string source, string stackTrace = null)
    {
        // Create error info
        var errorInfo = new ErrorInfo(message, severity, source, stackTrace);

        // Add to recent errors
        _recentErrors.Add(errorInfo);

        // Trim if too many errors
        if (_recentErrors.Count > MaxStoredErrors)
        {
            _recentErrors.RemoveAt(0);
        }

        // Write to log file
        WriteToLogFile(errorInfo);

        // Log to console based on severity
        switch (severity)
        {
            case ErrorSeverity.Info:
                GD.Print($"[INFO] [{source}] {message}");
                break;
            case ErrorSeverity.Warning:
                GD.Print($"[WARNING] [{source}] {message}");
                break;
            case ErrorSeverity.Error:
                GD.PrintErr($"[ERROR] [{source}] {message}");
                break;
            case ErrorSeverity.Critical:
                GD.PrintErr($"[CRITICAL] [{source}] {message}");
                break;
        }

        // Trigger event
        OnErrorLogged?.Invoke(errorInfo);
    }

    // Get recent errors
    public List<ErrorInfo> GetRecentErrors(int count = 10)
    {
        int startIndex = Math.Max(0, _recentErrors.Count - count);
        return _recentErrors.GetRange(startIndex, _recentErrors.Count - startIndex);
    }

    // Clear all stored errors
    public void ClearErrors()
    {
        _recentErrors.Clear();
    }

    private void WriteToLogFile(ErrorInfo entry)
    {
        try
        {
            string logEntry = $"[{entry.Timestamp:yyyy-MM-dd HH:mm:ss}] [{entry.Severity}] {entry.Message}";
            
            if (entry.StackTrace != null)
            {
                logEntry += $"\nStackTrace: {entry.StackTrace}";
            }
            
            // Append to log file
            using (var file = Godot.FileAccess.Open(_logFilePath, Godot.FileAccess.ModeFlags.WriteRead))
            {
                if (file != null)
                {
                    file.SeekEnd();
                    file.StoreString(logEntry + "\n");
                }
            }
        }
        catch (Exception ex)
        {
            GD.PrintErr($"Failed to write to log file: {ex.Message}");
        }
    }

    private void _OnTreeExiting()
    {
        LogInfo("Application shutting down", "ErrorHandler");
    }
} 
```

File: C:/Users/Shad/Documents/tensigh-godot/Scripts/PersistenceManager.cs
```csharp
#nullable enable
using Godot;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.Json;

namespace Tensigh
{
    /// <summary>
    /// Handles saving and loading the application state (pages, blocks, relations)
    /// by coordinating with the relevant managers.
    /// </summary>
    public class PersistenceManager
    {
        private readonly PageManager _pageManager;
        private readonly TextBlockManager _textBlockManager;
        private readonly RelationManager _relationManager;

        // JSON options can be configured here if needed elsewhere too
        private static readonly JsonSerializerOptions _jsonOptions = new JsonSerializerOptions
        {
            WriteIndented = true,
            Converters = { new Vector3Converter() } // Include necessary converters
        };

        public PersistenceManager(PageManager pageManager, TextBlockManager textBlockManager, RelationManager relationManager)
        {
            _pageManager = pageManager ?? throw new ArgumentNullException(nameof(pageManager));
            _textBlockManager = textBlockManager ?? throw new ArgumentNullException(nameof(textBlockManager));
            _relationManager = relationManager ?? throw new ArgumentNullException(nameof(relationManager));
        }

        /// <summary>
        /// Updates the data object for the current page by gathering state 
        /// from the TextBlockManager and RelationManager.
        /// </summary>
        private void UpdateCurrentPageData()
        {
            var currentPageData = _pageManager.GetCurrentPage();
            if (currentPageData != null)
            {
                _textBlockManager.UpdatePageData(currentPageData);
                _relationManager.UpdatePageData(currentPageData);
                GD.Print("PersistenceManager: Updated current page data in managers.");
            }
            else
            {
                GD.Print("PersistenceManager: No current page data to update.");
            }
        }

        /// <summary>
        /// Saves the current state to the specified file path.
        /// </summary>
        /// <param name="filePath">The path (e.g., "user://thoughts.json") to save to.</param>
        public void Save(string filePath)
        {
            try
            {
                UpdateCurrentPageData(); // Ensure current page data is up-to-date in managers
                
                var pageManagerSaveData = _pageManager.GetSaveData();
                var currentLastOpenedPath = _pageManager.LastOpenedPath; // Get from PageManager

                var saveFile = new SaveFile
                {
                    PageManagerData = pageManagerSaveData,
                    LastOpenedPath = currentLastOpenedPath
                };
                
                var json = JsonSerializer.Serialize(saveFile, _jsonOptions);
                
                using var file = Godot.FileAccess.Open(filePath, Godot.FileAccess.ModeFlags.Write);
                if (file == null)
                {
                    GD.PrintErr($"PersistenceManager: Failed to open {filePath} for writing. Error: {Godot.FileAccess.GetOpenError()}");
                    return;
                }
                file.StoreString(json);
                GD.Print($"PersistenceManager: Saved {_pageManager.Pages.Count} pages to {filePath}");
            }
            catch (Exception ex)
            {
                GD.PrintErr($"PersistenceManager: Failed to save state to {filePath}. Exception: {ex.Message}\n{ex.StackTrace}");
            }
        }

        /// <summary>
        /// Loads the application state from the specified file path.
        /// </summary>
        /// <param name="filePath">The path (e.g., "user://thoughts.json") to load from.</param>
        /// <returns>True if loading was successful, false otherwise.</returns>
        public bool Load(string filePath)
        {
            try
            {
                if (!Godot.FileAccess.FileExists(filePath))
                {
                    GD.Print($"PersistenceManager: Save file not found at {filePath}.");
                    return false; // Indicate failure: file doesn't exist
                }

                GD.Print($"PersistenceManager: Loading from {filePath}");
                string json = Godot.FileAccess.GetFileAsString(filePath);
                
                if (string.IsNullOrEmpty(json))
                {
                    GD.PrintErr($"PersistenceManager: Save file at {filePath} is empty.");
                    return false; // Indicate failure: empty file
                }

                var saveFile = JsonSerializer.Deserialize<SaveFile>(json, _jsonOptions);
                            
                if (saveFile?.PageManagerData == null)
                {
                     GD.PrintErr($"PersistenceManager: Failed to deserialize SaveFile or PageManagerData was null from {filePath}.");
                    return false; // Indicate failure: deserialization issue
                }

                // Load data into PageManager
                _pageManager.LoadFromSaveData(saveFile.PageManagerData);
                _pageManager.LastOpenedPath = saveFile.LastOpenedPath; // Set the loaded path
                
                GD.Print($"PersistenceManager: Successfully loaded data for {_pageManager.Pages.Count} pages from {filePath}.");
                return true; // Indicate success

            }
            catch (JsonException jsonEx)
            {
                GD.PrintErr($"PersistenceManager: Error deserializing JSON from {filePath}. Exception: {jsonEx.Message}");
                return false; // Indicate failure: JSON error
            }
            catch (Exception ex)
            {
                GD.PrintErr($"PersistenceManager: Failed to load state from {filePath}. Exception: {ex.Message}\n{ex.StackTrace}");
                return false; // Indicate failure: other error
            }
        }
    }
} 
```

File: C:/Users/Shad/Documents/tensigh-godot/Scripts/TextBlock.cs
```csharp
using Godot;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json.Serialization;

namespace Tensigh
{
    public class TextBlock
    {
        [JsonPropertyName("id")]
        public string Id { get; set; } = Guid.NewGuid().ToString();

        [JsonPropertyName("text")]
        public string Text { get; set; }

        [JsonPropertyName("position")]
        [JsonConverter(typeof(Vector3Converter))]
        public Vector3 Position { get; set; }

        [JsonPropertyName("scale")]
        [JsonConverter(typeof(Vector3Converter))]
        public Vector3 Scale { get; set; }

        [JsonPropertyName("relations")]
        public List<Relation> Relations { get; set; } = new List<Relation>();

        [JsonPropertyName("boxWidth")]
        public float BoxWidth { get; set; }

        [JsonPropertyName("boxHeight")]
        public float BoxHeight { get; set; }

        [JsonPropertyName("boxDepth")]
        public float BoxDepth { get; set; } = 0.01f;

        [JsonIgnore]
        public Label3D Label { get; set; }

        [JsonIgnore]
        public bool IsEditing { get; set; }

        [JsonIgnore]
        public bool IsHovered { get; set; }

        [JsonIgnore]
        public Color TextColor { get; set; } = Colors.White;

        [JsonIgnore]
        public MeshInstance3D BoundingBox { get; set; }

        [JsonIgnore]
        public int CursorPosition { get; set; } = 0; // Track cursor position
        
        [JsonIgnore]
        public bool ShowCursor { get; set; } = true; // Used for cursor blinking

        [JsonIgnore]
        public bool IsSelected { get; set; }
        
        [JsonIgnore]
        public Color Color { get; set; } = Colors.White;

        private const float CHAR_WIDTH = 24.0f;  // Increased from 16.0f for larger text
        private const float CHAR_HEIGHT = 32.0f;  // Increased from 24.0f for larger text
        private const float BOX_PADDING = 0.3f;   // Reduced padding for closer text
        private const float TEXT_SCALE = 0.8f;    // Increased from 0.5f for larger overall size
        private const float MAX_TEXT_WIDTH = 1000.0f;  // Increased maximum width
        private const float MAX_TEXT_HEIGHT = 800.0f;  // Increased maximum height

        public TextBlock(string text, Vector3 position)
        {
            Text = text;
            Position = position;
            Scale = new Vector3(TEXT_SCALE, TEXT_SCALE, TEXT_SCALE);
            IsEditing = false;
            Label = new Label3D();
            Label.Text = text;
            Label.Position = position;
            Label.Scale = Scale;
            Label.OutlineSize = 0;
            Label.OutlineModulate = new Color(0, 0, 0, 0);
            
            // Ensure no glow effect by setting MaterialOverride to null
            Label.MaterialOverride = null;
            
            // Initialize cursor at the end of the text
            CursorPosition = text.Length;
            
            GD.Print($"Creating TextBlock at position: {position} with scale: {Scale}");
        }

        public void UpdateTextDisplay()
        {
            if (Label == null) return;

            // If we're editing, preserve the original scale
            if (IsEditing)
            {
                // Just update the text content while keeping the original scale
                Label.Text = Text;
                Label.Position = Position;
                Label.MaterialOverride = null;
                return;
            }

            // Calculate text dimensions based on content
            var lines = Text.Split('\n');
            var maxLineLength = lines.Max(line => line.Length);
            var textWidth = maxLineLength * CHAR_WIDTH;
            var textHeight = lines.Length * CHAR_HEIGHT;

            // Calculate scale to fit within maximum dimensions while maintaining aspect ratio
            var scaleX = MAX_TEXT_WIDTH / textWidth;
            var scaleY = MAX_TEXT_HEIGHT / textHeight;
            var scale = Mathf.Min(scaleX, scaleY) * TEXT_SCALE; // Apply base text scale

            // Apply uniform scale
            Label.Scale = new Vector3(scale, scale, scale);

            // Update text content
            Label.Text = Text;
            
            // Ensure position is maintained
            Label.Position = Position;
            
            // Ensure no glow effect by setting MaterialOverride to null
            Label.MaterialOverride = null;
        }

        // Default constructor for JSON deserialization
        public TextBlock()
        {
            IsEditing = false;
            Label = new Label3D();
            Scale = new Vector3(TEXT_SCALE, TEXT_SCALE, TEXT_SCALE);
            Label.Scale = Scale;
            Label.OutlineSize = 0;
            Label.OutlineModulate = new Color(0, 0, 0, 0);
            
            // Ensure no glow effect by setting MaterialOverride to null
            Label.MaterialOverride = null;
            
            GD.Print("Created empty TextBlock");
        }
    }
} 
```

File: C:/Users/Shad/Documents/tensigh-godot/Scripts/PageManager.cs
```csharp
#nullable enable
using Godot;
using System;
using System.Collections.Generic;
using System.Text.Json.Serialization;

namespace Tensigh
{
    public class PageManager
    {
        [JsonPropertyName("pages")]
        public List<TextBlockCollection> Pages { get; private set; } = new List<TextBlockCollection>();

        [JsonPropertyName("currentPageIndex")]
        public int CurrentPageIndex { get; private set; } = -1;

        [JsonPropertyName("lastOpenedPath")]
        public string? LastOpenedPath { get; set; }

        public event Action<TextBlockCollection?>? CurrentPageChanged;

        public PageManager()
        {
            LastOpenedPath = null;
        }

        public void AddPage(string? name = null)
        {
            var page = new TextBlockCollection();
            page.Name = name ?? $"Page {Pages.Count + 1}";
            
            Pages.Add(page);
            SwitchToPage(Pages.Count - 1);
        }

        public void RemovePage(int index)
        {
            if (index >= 0 && index < Pages.Count)
            {
                bool isRemovingCurrent = (index == CurrentPageIndex);
                Pages.RemoveAt(index);
                
                int newIndex = CurrentPageIndex;
                if (isRemovingCurrent)
                {
                    newIndex = Math.Min(index, Pages.Count - 1);
                }
                else if (index < CurrentPageIndex)
                {
                    newIndex--;
                }
                
                SwitchToPage(newIndex);
            }
        }

        public void SwitchToPage(int index)
        {
            if (index >= -1 && index < Pages.Count)
            {
                if (index != CurrentPageIndex)
                {
                    CurrentPageIndex = index;
                    GD.Print($"Switched to page index: {CurrentPageIndex}");
                    CurrentPageChanged?.Invoke(GetCurrentPage());
                }
            }
            else
            {
                GD.PushWarning($"Attempted to switch to invalid page index: {index}");
            }
        }

        public TextBlockCollection? GetCurrentPage()
        {
            if (CurrentPageIndex >= 0 && CurrentPageIndex < Pages.Count)
                return Pages[CurrentPageIndex];
            return null;
        }

        public PageManagerSaveData GetSaveData()
        {
            return new PageManagerSaveData
            {
                Pages = this.Pages,
                CurrentPageIndex = this.CurrentPageIndex
            };
        }

        public void LoadFromSaveData(PageManagerSaveData data)
        {
            if (data != null)
            {
                Pages = data.Pages ?? new List<TextBlockCollection>();
                CurrentPageIndex = data.CurrentPageIndex;
                if (CurrentPageIndex < 0 || CurrentPageIndex >= Pages.Count)
                {
                    CurrentPageIndex = Pages.Count > 0 ? 0 : -1;
                }
                GD.Print($"PageManager loaded {Pages.Count} pages. Current index: {CurrentPageIndex}");
                CurrentPageChanged?.Invoke(GetCurrentPage());
            }
            else
            {
                GD.PrintErr("Failed to load PageManager data: Save data was null.");
                Pages = new List<TextBlockCollection>();
                CurrentPageIndex = -1;
            }
        }

        /// <summary>
        /// Adds a pre-populated TextBlockCollection (page data) to the list 
        /// and switches to it, triggering the CurrentPageChanged event.
        /// </summary>
        /// <param name="pageData">The page data to add.</param>
        public void AddExistingPage(TextBlockCollection pageData)
        {
            if (pageData == null)
            {
                GD.PrintErr("PageManager: Attempted to add null page data.");
                return;
            }
            Pages.Add(pageData);
            SwitchToPage(Pages.Count - 1); // Switch to the newly added page
            GD.Print($"PageManager: Added existing page '{pageData.Name}'.");
        }
    }
} 
```

File: C:/Users/Shad/Documents/tensigh-godot/Scripts/ErrorDisplay.cs
```csharp
using Godot;
using System;
using System.Collections.Generic;

public partial class ErrorDisplay : Control
{
    // Reference to the error handler
    private ErrorHandler _errorHandler;
    
    // UI elements
    private RichTextLabel _errorLogLabel;
    private Button _clearButton;
    private Button _toggleButton;
    private Panel _errorPanel;
    
    // Maximum number of errors to display
    private const int MAX_DISPLAYED_ERRORS = 10;
    
    // Whether the error panel is visible
    private bool _isVisible = false;

    public override void _Ready()
    {
        // Get UI elements
        _errorLogLabel = GetNode<RichTextLabel>("ErrorPanel/ErrorLogLabel");
        _clearButton = GetNode<Button>("ErrorPanel/ClearButton");
        _toggleButton = GetNode<Button>("ToggleButton");
        _errorPanel = GetNode<Panel>("ErrorPanel");
        
        // Connect button signals
        _clearButton.Connect("pressed", new Callable(this, nameof(_OnClearButtonPressed)));
        _toggleButton.Connect("pressed", new Callable(this, nameof(_OnToggleButtonPressed)));
        
        // Get error handler instance
        _errorHandler = ErrorHandler.Instance;
        
        // Subscribe to error events
        if (_errorHandler != null)
        {
            _errorHandler.OnErrorLogged += _OnErrorLogged;
            
            // Initial update
            UpdateErrorDisplay();
        }
        else
        {
            GD.PrintErr("ErrorHandler instance not found!");
        }
        
        // Initially hide the error panel
        _errorPanel.Visible = false;
    }

    public override void _ExitTree()
    {
        // Unsubscribe from events when the node is removed
        if (_errorHandler != null)
        {
            _errorHandler.OnErrorLogged -= _OnErrorLogged;
        }
    }

    private void _OnErrorLogged(ErrorHandler.ErrorInfo errorInfo)
    {
        // Update the display when a new error is logged
        UpdateErrorDisplay();
    }

    private void UpdateErrorDisplay()
    {
        if (_errorHandler == null) return;
        
        // Get recent errors
        var recentErrors = _errorHandler.GetRecentErrors(MAX_DISPLAYED_ERRORS);
        
        // Clear the label
        _errorLogLabel.Text = "";
        
        // Add each error to the display
        foreach (var error in recentErrors)
        {
            string severityColor = error.Severity switch
            {
                ErrorHandler.ErrorSeverity.Info => "white",
                ErrorHandler.ErrorSeverity.Warning => "yellow",
                ErrorHandler.ErrorSeverity.Error => "red",
                ErrorHandler.ErrorSeverity.Critical => "purple",
                _ => "gray"
            };
            
            string severityText = error.Severity.ToString();
            string timestamp = error.Timestamp.ToString("HH:mm:ss");
            
            _errorLogLabel.Text += $"[color={severityColor}][{severityText}][/color] [{timestamp}] {error.Message}\n";
            
            if (!string.IsNullOrEmpty(error.StackTrace))
            {
                _errorLogLabel.Text += $"[color=red]Stack Trace: {error.StackTrace}[/color]\n";
            }
        }
    }

    private void _OnClearButtonPressed()
    {
        if (_errorHandler != null)
        {
            _errorHandler.ClearErrors();
            UpdateErrorDisplay();
        }
    }

    private void _OnToggleButtonPressed()
    {
        _isVisible = !_isVisible;
        _errorPanel.Visible = _isVisible;
        _toggleButton.Text = _isVisible ? "Hide Errors" : "Show Errors";
    }
} 
```

File: C:/Users/Shad/Documents/tensigh-godot/.godot/mono/temp/obj/Tensigh.csproj.nuget.dgspec.json
```json
{
  "format": 1,
  "restore": {
    "C:\\Users\\Shad\\Documents\\tensigh-godot\\Tensigh.csproj": {}
  },
  "projects": {
    "C:\\Users\\Shad\\Documents\\tensigh-godot\\Tensigh.csproj": {
      "version": "1.0.0",
      "restore": {
        "projectUniqueName": "C:\\Users\\Shad\\Documents\\tensigh-godot\\Tensigh.csproj",
        "projectName": "Tensigh",
        "projectPath": "C:\\Users\\Shad\\Documents\\tensigh-godot\\Tensigh.csproj",
        "packagesPath": "C:\\Users\\Shad\\.nuget\\packages\\",
        "outputPath": "C:\\Users\\Shad\\Documents\\tensigh-godot\\.godot\\mono\\temp\\obj\\",
        "projectStyle": "PackageReference",
        "fallbackFolders": [
          "C:\\Program Files (x86)\\Microsoft Visual Studio\\Shared\\NuGetPackages"
        ],
        "configFilePaths": [
          "C:\\Users\\Shad\\AppData\\Roaming\\NuGet\\NuGet.Config",
          "C:\\Program Files (x86)\\NuGet\\Config\\Microsoft.VisualStudio.FallbackLocation.config",
          "C:\\Program Files (x86)\\NuGet\\Config\\Microsoft.VisualStudio.Offline.config"
        ],
        "originalTargetFrameworks": [
          "net8.0"
        ],
        "sources": {
          "C:\\Program Files (x86)\\Microsoft SDKs\\NuGetPackages\\": {},
          "https://api.nuget.org/v3/index.json": {}
        },
        "frameworks": {
          "net8.0": {
            "targetAlias": "net8.0",
            "projectReferences": {}
          }
        },
        "warningProperties": {
          "warnAsError": [
            "NU1605"
          ]
        },
        "restoreAuditProperties": {
          "enableAudit": "true",
          "auditLevel": "low",
          "auditMode": "direct"
        },
        "SdkAnalysisLevel": "9.0.200"
      },
      "frameworks": {
        "net8.0": {
          "targetAlias": "net8.0",
          "dependencies": {
            "Godot.SourceGenerators": {
              "target": "Package",
              "version": "[4.4.1, )"
            },
            "GodotSharp": {
              "target": "Package",
              "version": "[4.4.1, )"
            },
            "GodotSharpEditor": {
              "target": "Package",
              "version": "[4.4.1, )"
            }
          },
          "imports": [
            "net461",
            "net462",
            "net47",
            "net471",
            "net472",
            "net48",
            "net481"
          ],
          "assetTargetFallback": true,
          "warn": true,
          "frameworkReferences": {
            "Microsoft.NETCore.App": {
              "privateAssets": "all"
            }
          },
          "runtimeIdentifierGraphPath": "C:\\Program Files\\dotnet\\sdk\\9.0.202/PortableRuntimeIdentifierGraph.json"
        }
      }
    }
  }
}
```

File: C:/Users/Shad/Documents/tensigh-godot/Scripts/DocumentLoader.cs
```csharp
#nullable enable
using Godot;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace Tensigh
{
    /// <summary>
    /// Handles loading specific document formats (.txt) and parsing them 
    /// into a TextBlockCollection data structure.
    /// </summary>
    public class DocumentLoader
    {
        /// <summary>
        /// Loads a .txt document, parsing blocks separated by double newlines,
        /// and returns a TextBlockCollection representing the page data.
        /// </summary>
        /// <param name="filePath">The full path to the .txt file.</param>
        /// <returns>A TextBlockCollection populated with data, or null if loading fails.</returns>
        public TextBlockCollection? LoadDocumentAsPage(string filePath)
        {
            try
            {
                if (!Godot.FileAccess.FileExists(filePath))
                {
                    GD.PrintErr($"DocumentLoader: File not found at {filePath}.");
                    return null;
                }

                string content = Godot.FileAccess.GetFileAsString(filePath);
                if (string.IsNullOrEmpty(content))
                {
                    GD.PrintErr($"DocumentLoader: File is empty at {filePath}.");
                    // Return an empty page instead of null? Depends on desired behavior.
                    // return new TextBlockCollection { Name = Path.GetFileNameWithoutExtension(filePath) };
                    return null; 
                }

                var pageData = new TextBlockCollection
                {
                    Name = Path.GetFileNameWithoutExtension(filePath) ?? "Loaded Document",
                    Blocks = new List<TextBlock>() // Initialize block list
                };

                var blockTexts = content.Split(new[] { "\r\n\r\n", "\n\n" }, StringSplitOptions.RemoveEmptyEntries);

                foreach (var blockText in blockTexts)
                {
                    if (!string.IsNullOrWhiteSpace(blockText))
                    {
                        // Create TextBlock DATA - Position is not set here, will be calculated by TextBlockManager during visual load.
                        var newBlockData = new TextBlock
                        {
                            Text = blockText.Trim(),
                            Id = Guid.NewGuid().ToString(), // Generate a new ID
                            Scale = new Vector3(0.5f, 0.5f, 0.5f) // Set default scale or load if available?
                            // Relations list is initialized by default TextBlock constructor
                        };
                        pageData.Blocks.Add(newBlockData);
                    }
                }
                
                GD.Print($"DocumentLoader: Successfully parsed {pageData.Blocks.Count} blocks from {filePath}.");
                return pageData;
            }
            catch (IOException ioEx)
            {
                 GD.PrintErr($"DocumentLoader: IO Error loading document from {filePath}. Exception: {ioEx.Message}");
                 return null;
            }
            catch (Exception ex)
            {
                GD.PrintErr($"DocumentLoader: Unexpected error loading document from {filePath}. Exception: {ex.Message}\n{ex.StackTrace}");
                return null;
            }
        }
    }
} 
```

File: C:/Users/Shad/Documents/tensigh-godot/Scripts/WebViewerManager.cs
```csharp
#nullable enable
using Godot;
using System;

namespace Tensigh
{
    public partial class WebViewerManager : Node
    {
        private Control? _webViewContainer; // Made nullable
        private Node? _webView; // Made nullable
        private bool _isVisible = false;
        
        // Removed constructor public WebViewerManager(Control container)
        
        // Added parameterless constructor
        public WebViewerManager()
        {
            // Initialize fields here if needed, or in _Ready
        }
        
        // Renamed Initialize to _Ready and made it override
        public override void _Ready()
        {
            base._Ready(); // Call base method
            // Create the web view container
            _webViewContainer = new Control
            {
                Name = "WebViewContainer", // Give it a name
                Visible = false, // Start hidden
                // Set layout properties if needed, e.g., anchors
                AnchorRight = 1.0f,
                AnchorBottom = 1.0f,
                GrowHorizontal = Control.GrowDirection.Both,
                GrowVertical = Control.GrowDirection.Both
            };
            AddChild(_webViewContainer); // Add container to the scene tree

            // TODO: Initialize web view component based on platform
            // This would depend on specific web view implementation
        }

        public void NavigateToUrl(string url)
        {
            if (_webView != null)
            {
                GD.Print($"Navigating to URL: {url}");
                // TODO: Call the actual web view navigation method
                // _webView.Navigate(url);
            }
            else
            {
                GD.PrintErr("Web view not initialized");
        }
        }

        public void ToggleVisibility()
        {
            _isVisible = !_isVisible;
            if (_webViewContainer != null) _webViewContainer.Visible = _isVisible;
            GD.Print($"Web viewer visibility: {_isVisible}");
                }

        public void Show()
        {
            _isVisible = true;
            if (_webViewContainer != null) _webViewContainer.Visible = true;
        }
        
        public void Hide()
                {
            _isVisible = false;
            if (_webViewContainer != null) _webViewContainer.Visible = false;
            }

        public bool IsVisible()
            {
            return _isVisible;
            }

        // Added 'new' keyword to Dispose
        public new void Dispose()
        {
            // Clean up web view resources
            // No need to QueueFree _webViewContainer, it's a child and will be freed with the parent
        }
    }
} 
```

File: C:/Users/Shad/Documents/tensigh-godot/Scenes/ErrorDisplay.tscn
```tscn
[gd_scene load_steps=2 format=3 uid="uid://b8j6q3y5n4m2p"]

[ext_resource type="Script" path="res://Scripts/ErrorDisplay.cs" id="1_2k3m4"]

[node name="ErrorDisplay" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_2k3m4")

[node name="ToggleButton" type="Button"]
layout_mode = 1
anchors_preset = 1
anchor_left = 1.0
anchor_right = 1.0
offset_left = -120.0
offset_top = 10.0
offset_right = -10.0
offset_bottom = 41.0
grow_horizontal = 0
text = "Show Errors"

[node name="ErrorPanel" type="Panel"]
layout_mode = 1
anchors_preset = 1
anchor_left = 1.0
anchor_right = 1.0
offset_left = -400.0
offset_top = 50.0
offset_right = -10.0
offset_bottom = 300.0
grow_horizontal = 0

[node name="ErrorLogLabel" type="RichTextLabel"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = 10.0
offset_top = 10.0
offset_right = -10.0
offset_bottom = -50.0
grow_horizontal = 2
grow_vertical = 2
bbcode_enabled = true
text = "No errors logged yet."

[node name="ClearButton" type="Button"]
layout_mode = 1
anchors_preset = 7
anchor_left = 0.5
anchor_top = 1.0
anchor_right = 0.5
anchor_bottom = 1.0
offset_left = -50.0
offset_top = -40.0
offset_right = 50.0
offset_bottom = -10.0
grow_horizontal = 2
grow_vertical = 0
text = "Clear" 
```

File: C:/Users/Shad/Documents/tensigh-godot/.godot/mono/temp/obj/Tensigh.csproj.nuget.g.props
```props
<?xml version="1.0" encoding="utf-8" standalone="no"?>
<Project ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition=" '$(ExcludeRestorePackageImports)' != 'true' ">
    <RestoreSuccess Condition=" '$(RestoreSuccess)' == '' ">True</RestoreSuccess>
    <RestoreTool Condition=" '$(RestoreTool)' == '' ">NuGet</RestoreTool>
    <ProjectAssetsFile Condition=" '$(ProjectAssetsFile)' == '' ">$(MSBuildThisFileDirectory)project.assets.json</ProjectAssetsFile>
    <NuGetPackageRoot Condition=" '$(NuGetPackageRoot)' == '' ">$(UserProfile)\.nuget\packages\</NuGetPackageRoot>
    <NuGetPackageFolders Condition=" '$(NuGetPackageFolders)' == '' ">C:\Users\Shad\.nuget\packages\;C:\Program Files (x86)\Microsoft Visual Studio\Shared\NuGetPackages</NuGetPackageFolders>
    <NuGetProjectStyle Condition=" '$(NuGetProjectStyle)' == '' ">PackageReference</NuGetProjectStyle>
    <NuGetToolVersion Condition=" '$(NuGetToolVersion)' == '' ">6.13.1</NuGetToolVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(ExcludeRestorePackageImports)' != 'true' ">
    <SourceRoot Include="C:\Users\Shad\.nuget\packages\" />
    <SourceRoot Include="C:\Program Files (x86)\Microsoft Visual Studio\Shared\NuGetPackages\" />
  </ItemGroup>
  <ImportGroup Condition=" '$(ExcludeRestorePackageImports)' != 'true' ">
    <Import Project="$(NuGetPackageRoot)godot.sourcegenerators\4.4.1\build\Godot.SourceGenerators.props" Condition="Exists('$(NuGetPackageRoot)godot.sourcegenerators\4.4.1\build\Godot.SourceGenerators.props')" />
  </ImportGroup>
</Project>
```

File: C:/Users/Shad/Documents/tensigh-godot/tensigh-godot.sln
```sln
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.0.31903.59
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Tensigh", "Tensigh.csproj", "{E69DE3B6-A1B0-6022-294C-FA6564FB1AF9}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{E69DE3B6-A1B0-6022-294C-FA6564FB1AF9}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{E69DE3B6-A1B0-6022-294C-FA6564FB1AF9}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{E69DE3B6-A1B0-6022-294C-FA6564FB1AF9}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{E69DE3B6-A1B0-6022-294C-FA6564FB1AF9}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {19E0BC62-63C3-4810-8A63-EA3385279E4B}
	EndGlobalSection
EndGlobal

```

File: C:/Users/Shad/Documents/tensigh-godot/project.godot
```godot
; Engine configuration file.
; It's best edited using the editor UI and not directly,
; since the parameters that go here are not all obvious.
;
; Format:
;   [section] ; section goes between []
;   param=value ; assign values to parameters

config_version=5

[application]

config/name="tensigh-godot"
run/main_scene="res://Scenes/DeskRoom.tscn"
config/features=PackedStringArray("4.4", "C#", "Forward Plus")
config/icon="res://icon.svg"

[autoload]

WebViewerManager="*res://Scripts/WebViewerManager.cs"
SceneManager="*res://Scripts/SceneManager.cs"

[dotnet]

project/assembly_name="Tensigh"

[input]

ui_zoom_in={
"deadzone": 0.5,
"events": [Object(InputEventMouseButton,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"button_mask":0,"position":Vector2(0, 0),"global_position":Vector2(0, 0),"factor":1.0,"button_index":4,"canceled":false,"pressed":false,"double_click":false,"script":null)
]
}
ui_zoom_out={
"deadzone": 0.5,
"events": [Object(InputEventMouseButton,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"button_mask":0,"position":Vector2(0, 0),"global_position":Vector2(0, 0),"factor":1.0,"button_index":5,"canceled":false,"pressed":false,"double_click":false,"script":null)
]
}

```

File: C:/Users/Shad/Documents/tensigh-godot/Scripts/Vector3Converter.cs
```csharp
using Godot;
using System;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace Tensigh
{
    public class Vector3Converter : JsonConverter<Vector3>
    {
        public override Vector3 Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            if (reader.TokenType != JsonTokenType.StartObject)
            {
                throw new JsonException("Expected start of object");
            }

            float x = 0, y = 0, z = 0;

            while (reader.Read())
            {
                if (reader.TokenType == JsonTokenType.EndObject)
                {
                    return new Vector3(x, y, z);
                }

                if (reader.TokenType != JsonTokenType.PropertyName)
                {
                    throw new JsonException("Expected property name");
                }

                string propertyName = reader.GetString();
                reader.Read();

                switch (propertyName.ToLower())
                {
                    case "x":
                        x = reader.GetSingle();
                        break;
                    case "y":
                        y = reader.GetSingle();
                        break;
                    case "z":
                        z = reader.GetSingle();
                        break;
                    default:
                        reader.Skip();
                        break;
                }
            }

            throw new JsonException("Expected end of object");
        }

        public override void Write(Utf8JsonWriter writer, Vector3 value, JsonSerializerOptions options)
        {
            writer.WriteStartObject();
            writer.WriteNumber("x", value.X);
            writer.WriteNumber("y", value.Y);
            writer.WriteNumber("z", value.Z);
            writer.WriteEndObject();
        }
    }
} 
```

File: C:/Users/Shad/Documents/tensigh-godot/icon.svg.import
```import
[remap]

importer="texture"
type="CompressedTexture2D"
uid="uid://c3htsklh71lo7"
path="res://.godot/imported/icon.svg-218a8f2b3041327d8a5756f3a245f83b.ctex"
metadata={
"vram_texture": false
}

[deps]

source_file="res://icon.svg"
dest_files=["res://.godot/imported/icon.svg-218a8f2b3041327d8a5756f3a245f83b.ctex"]

[params]

compress/mode=0
compress/high_quality=false
compress/lossy_quality=0.7
compress/hdr_compression=1
compress/normal_map=0
compress/channel_pack=0
mipmaps/generate=false
mipmaps/limit=-1
roughness/mode=0
roughness/src_normal=""
process/fix_alpha_border=true
process/premult_alpha=false
process/normal_map_invert_y=false
process/hdr_as_srgb=false
process/hdr_clamp_exposure=false
process/size_limit=0
detect_3d/compress_to=1
svg/scale=1.0
editor/scale_with_editor_scale=false
editor/convert_colors_with_editor_theme=false

```

File: C:/Users/Shad/Documents/tensigh-godot/Scripts/SaveFile.cs
```csharp
#nullable enable
using Godot;
using System;
using System.Collections.Generic;
using System.Text.Json.Serialization;

namespace Tensigh
{
    // New class to hold page manager state for serialization
    public class PageManagerSaveData
    {
        [JsonPropertyName("pages")]
        public List<TextBlockCollection> Pages { get; set; } = new List<TextBlockCollection>();

        [JsonPropertyName("currentPageIndex")]
        public int CurrentPageIndex { get; set; } = -1;

        // Add other PageManager specific data if needed in the future (e.g., CameraSettings?)
        // [JsonPropertyName("cameraSettings")]
        // public CameraSettings CameraSettings { get; set; }
    }

    public class SaveFile
    {
        // Changed Pages to PageManagerData
        [JsonPropertyName("pageManagerData")]
        public PageManagerSaveData PageManagerData { get; set; }
        
        [JsonPropertyName("lastOpenedPath")]
        public string? LastOpenedPath { get; set; } // Made nullable
        
        public SaveFile()
        {
            // Initialize with new PageManagerSaveData
            PageManagerData = new PageManagerSaveData();
            LastOpenedPath = null;
        }
    }
} 
```

File: C:/Users/Shad/Documents/tensigh-godot/.godot/mono/temp/obj/project.nuget.cache
```cache
{
  "version": 2,
  "dgSpecHash": "gvWybc1d4RU=",
  "success": true,
  "projectFilePath": "C:\\Users\\Shad\\Documents\\tensigh-godot\\Tensigh.csproj",
  "expectedPackageFiles": [
    "C:\\Users\\Shad\\.nuget\\packages\\godot.sourcegenerators\\4.4.1\\godot.sourcegenerators.4.4.1.nupkg.sha512",
    "C:\\Users\\Shad\\.nuget\\packages\\godotsharp\\4.4.1\\godotsharp.4.4.1.nupkg.sha512",
    "C:\\Users\\Shad\\.nuget\\packages\\godotsharpeditor\\4.4.1\\godotsharpeditor.4.4.1.nupkg.sha512"
  ],
  "logs": []
}
```

File: C:/Users/Shad/Documents/tensigh-godot/Scenes/WebViewer.tscn
```tscn
[gd_scene load_steps=2 format=3 uid="uid://dxxx"]

[ext_resource type="Script" path="res://Scripts/WebViewer.cs" id="1_xxxxx"]

[node name="WebViewer" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_xxxxx")

[node name="TextureRect" type="TextureRect" parent="."]
custom_minimum_size = Vector2(1024, 768)
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
expand_mode = 1
stretch_mode = 5 
```

File: C:/Users/Shad/Documents/tensigh-godot/Scripts/Relation.cs
```csharp
using Godot;
using System;
using System.Text.Json.Serialization;

namespace Tensigh
{
    public class Relation
    {
        [JsonPropertyName("sourceId")]
        public string SourceId { get; set; }

        [JsonPropertyName("targetId")]
        public string TargetId { get; set; }

        [JsonPropertyName("label")]
        public string Label { get; set; }

        [JsonIgnore]
        public Label3D VisualLabel { get; set; }

        public Relation(string sourceId, string targetId, string label = "")
        {
            SourceId = sourceId;
            TargetId = targetId;
            Label = label;
        }
    }
} 
```

File: C:/Users/Shad/Documents/tensigh-godot/Scripts/TextBlockCollection.cs
```csharp
using Godot;
using System;
using System.Collections.Generic;
using System.Text.Json.Serialization;

namespace Tensigh
{
    public class TextBlockCollection
    {
        [JsonPropertyName("blocks")]
        public List<TextBlock> Blocks { get; set; }

        [JsonPropertyName("relations")]
        public List<Relation> Relations { get; set; }

        [JsonPropertyName("name")]
        public string Name { get; set; }

        public TextBlockCollection()
        {
            Blocks = new List<TextBlock>();
            Relations = new List<Relation>();
            Name = "Untitled Page";
        }
    }
} 
```

File: C:/Users/Shad/Documents/tensigh-godot/Scripts/CameraSettings.cs
```csharp
using Godot;
using System;
using System.Text.Json.Serialization;

namespace Tensigh
{
    public class CameraSettings
    {
        [JsonPropertyName("position")]
        [JsonConverter(typeof(Vector3Converter))]
        public Vector3 Position { get; set; }

        [JsonPropertyName("rotation")]
        [JsonConverter(typeof(Vector3Converter))]
        public Vector3 Rotation { get; set; }

        public CameraSettings()
        {
            Position = new Vector3(0, 0, 4);
            Rotation = Vector3.Zero;
        }
    }
} 
```

File: C:/Users/Shad/Documents/tensigh-godot/Scripts/default_env.tres
```tres
[gd_resource type="Environment" load_steps=2 format=2]

[sub_resource type="Sky" id=1]

[resource]
background_mode = 2
background_sky = SubResource( 1 )
ambient_light_color = Color( 1, 1, 1, 1 )
ambient_light_energy = 0.28
ambient_light_sky_contribution = 0.0
ssao_blur = 1

```

File: C:/Users/Shad/Documents/tensigh-godot/Tensigh.csproj
```csproj
<Project Sdk="Godot.NET.Sdk/4.4.1">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <RootNamespace>Tensigh</RootNamespace>
    <EnableDynamicLoading>true</EnableDynamicLoading>
  </PropertyGroup>
</Project> 
```

File: C:/Users/Shad/Documents/tensigh-godot/.cursor/rules/tensigh-godot-rules.mdc
```mdc
---
description: 
globs: 
alwaysApply: true
---

# Your rule content
Use Godot 4.X C#

- You can @ files here
- You can use markdown but dont have to

```

File: C:/Users/Shad/Documents/tensigh-godot/.godot/mono/temp/obj/Tensigh.csproj.nuget.g.targets
```targets
<?xml version="1.0" encoding="utf-8" standalone="no"?>
<Project ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
```

File: C:/Users/Shad/Documents/tensigh-godot/.gitattributes
```gitattributes
# Normalize EOL for all files that Git considers text files.
* text=auto eol=lf

```

File: C:/Users/Shad/Documents/tensigh-godot/.gitignore
```gitignore
# Godot 4+ specific ignores
.godot/
/android/
/cef_artifacts/
```

File: C:/Users/Shad/Documents/tensigh-godot/Scripts/ErrorHandler.cs.uid
```uid
uid://bt4ldgc8ivk2k

```

File: C:/Users/Shad/Documents/tensigh-godot/Scripts/WebViewer.cs.uid
```uid
uid://bhf2d11yh26f3

```

File: C:/Users/Shad/Documents/tensigh-godot/.editorconfig
```ini
root = true

[*]
charset = utf-8

```

File: C:/Users/Shad/Documents/tensigh-godot/Scripts/GDCefWrapper.gd.uid
```uid
uid://dewx7uxf1qywr

```

File: C:/Users/Shad/Documents/tensigh-godot/Scripts/ThoughtSpace.cs.uid
```uid
uid://sxgqi84h2blt

```

File: C:/Users/Shad/Documents/tensigh-godot/Scripts/DeskRoom.cs.uid
```uid
uid://cns34nv14v816

```

File: C:/Users/Shad/Documents/tensigh-godot/Scripts/ErrorDisplay.cs.uid
```uid
uid://50t1wemtsaqc

```

</file_contents>

<user_instructions>
Analyze the code for refactoring
</user_instructions>